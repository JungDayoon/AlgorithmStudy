# [BOJ]/[19237] 어른 상어

## *- simulation -*

* `int[][] Time` : 각위치의 냄새 남은 시간
* `int[][] Smell` : 냄새가 남아있다면 누구 냄새인지 (상어 번호)
* `ArrayList<Shark> sharks` : 남아았는 상어 리스트
  * `int num, r, c` : 상어의 번호, 위치 좌표(`r`, `c`)
  * 상어의 번호에 따라 오름차순으로 정렬한다.
* `PriorityMove[] pm` : 각 상어의 이동 우선순위

### Solution

1. 남아있는 모든 상어를 이동시킨다.

   `void MoveSharks(int N, int K)`

   : 상어위치의 상하좌우를 확인하는데, 빈공간과 현재 상어냄새가 있는 공간의 개수를 구한다.

   * 빈공간이 하나있다면, 그 공간으로 이동

   * 빈공간이 여러 곳이라면, 상어의 이전 방향에 따른 우선순위에 맞춰 이동
   * 빈공간은 없는데, 현재 상어냄새 공간이 한 자리라면, 그 공간으로 이동
   * 빈공간이 없고, 현재 상어냄새 공간이 여러 곳이라면, 이전방향에 따른 우선순위에 맞춰 이동

2. 냄새의 남은 시간을 `1`씩 줄인다.

   `void ReduceTime(int N)`

   : 자리에 냄새가 있다면 `1`줄이고, 만약 `1`만큼 줄였을 때 `0`이 되었다면 `Smell`배열에서 해당 상어 번호도 지워준다.

3. 이동시킨 상어의 냄새를 남긴다.

   `void SmellShark(int K)`

   : 남아있는 상어를 스캔하면서 상어가 있는 위치에 해당하는 `Smell`배열에는 상어의 번호를,  `Time`배열에는 `K` 값을 넣어준다.

   * 이때, 만약 `Time[r][c] == K`라면 이미 숫자가 작은 상어가 냄새를 풍긴 것으로, 이후에 온 번호가 큰 상어는 쫓겨나야 되므로 이 상어를 삭제한다.

     > `sharks`는 상어의 번호대로 오름차순으로 정렬되어있다.

4. 지속시간 `time`을 `+1`해준다.

5. 1~4과정을 상어가 1마리 남을 때까지 반복한다.

   * 만약 `time==1000`일 때에도 종료되지 않았으면 `time=-1`로 바꿔주고 종료한다.

     > `time == 1000 `일 때, 반복문을 그냥 `break`하고, `time`이 `1000`이면 `-1`을 리턴해주었었는데, 이렇게 되면 `time == 1000`일 때 상어가 한마리남았어도 `-1`을 리턴하게된다.
     >
     > 따라서, `time == 1000`이면 `-1`로 바꿔준 후 `break`해주어야 올바른 리턴값을 가진다.



