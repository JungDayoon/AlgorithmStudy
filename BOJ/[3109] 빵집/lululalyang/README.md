# [BOJ]/[3109] 빵집

## *- DFS -*

```java
boolean[][] visited; // 파이프 놓인 여부
boolean[][] chkDone; // false라면 파이프를 놓을 수 없다고 이미 확인된 곳, true면 그렇지 않은 곳
```

`0`번 행부터 `R-1`번 행까지 `dfs()`를 통해 파이프를 놓을 수 있는지 확인한다.

```java
boolean dfs(int x, int y, boolean[][] visited, boolean[][] chkDone)
```

1. 만약 `y`가 `C-1`이라면, 원웅이의 빵집에 도착한 것으로 파이프를 완성한 것. => `true`를 리턴한다.

2. 그렇지 않으면, 현재 위치에서 다음 위치으로 잇는 파이프를 놓을 수 있는지 확인한다. 

   다음 위치가

   * 범위 내에 속하고, `chkDone`이 `true`일때,

     * 벽이 아니고, 파이프가 놓여있지 않은 곳이라면,

       파이프를 놓고 (`visited`값을 `true`로) `dfs`를 재귀 호출한다.

       * 이 리턴값이 `true`라면, 파이프를 완성한 것으로 `true`를 리턴.

       * `false`라면, 놓았던 파이프를 다시 제거하고 (`visited`값을 `false`로) 다른 방향의 위치를 확인한다.

3. 만약, 현재 위치에서 다음 위치로 파이프를 놓을 수 없다면

   `chkDone`을 `false`로 설정 후, `false`를 리턴.

각 행마다 호출한 `dfs()`값이 `true`라면 파이프를 완성한 것으로 총 파이프 개수인 `res`값을 `+1`해준다.

* `res`값이 최종 결과값.

</br>

## :speaking_head:

* 처음에는 dfs를 `(0,0)`에서 한 번만 호출해서 백트래킹 방식으로 전체 행을 확인하도록 하였다. 이렇게 하면 *틀렸습니다* 였는데, 행을 연속적으로 확인하기 때문에 어느 행으로 파이프를 만들지 못하면 그 다음의 행들은 확인할 수 없기 때문에 틀린 것 같다.
* 그래서 각 행별로 dfs를 처리했는데 시간초과가 나와서 지혜 방법을 참고하였다. 시간초과가 날 때는 여러 번 계산되는 것을 줄이는 방법을 찾아보자 !!