# [BOJ]/[13334] 철로

## - PriorityQueue -

### solution

`int Max = 0` : 집과 사무실 위치가 모두 철로에 포함되는 사람의 최대 수

1. 각 `(hi, oi)`를 도착점 기준 오름차순인 `PriorityQueue<BasedEnd> pq`에 추가한다.

   * 이 때, 편의를 위해 `hi`와 `oi`중 작은 값이 시작점, 큰 값이 도착점이 되게 한다.

   * `class BasedEnd` 

     `int start, end` : 시작점과 도착점

     도착점 기준으로 오름차순이 되도록 하고, 도착점이 같다면 시작점 기준 오름차순이 되도록 설정한다.

2. `pq`에서 하나씩 꺼내면서 아래의 과정을 진행한다.

   `BasedEnd now = pq.poll()`

   1. 만약 `now`의 시작점과 도착점 사이 거리가 `d`보다 크면 아래 과정을 패스한다.

      * 길이 `d`인 철로안에 시작점과 도착점이 모두 포함되어야하므로 이 거리는 포함될 수 없다.

   2. 그렇지 않으면, `now`의 시작점을 오름차순 기준인 `PriorityQueue<Integer> startPoint`에 추가한다.

   3. `now`의 도착점에서 `d`만큼 앞으로 철로를 설치한다고 가정한다.

      `int thisStart = now.end - d; // 이번 철로의 시작점`

   4. 이번 철로에 포함되지 않는 시작점을 `q`에서 제거한다.

      즉, `startPoint`의 `peek()`이 `thisStart`보다 작으면 철로에 포함되지 않는 거리이므로 제거. => `peek()`이 `thisStart`보다 크거나 같을때까지 반복한다.

      (`pq`는 도착점 기준 오름차순으로 정렬되어 있으므로 `startPoint`에 있는 시작점의 거리는 `now`의 도착점 이내에 속하는 거리)

   5. 4번 과정을 거친 후의 `q.size()`가 이번 철로에 포함되는 사람의 수

      => 이 값으로 `Max`값을 갱신한다.

3. 모든 도착점을 확인한 후의 `Max`값이 최종 결과값.

</br>

## :speaking_head:

너무 어렵다 ㅜㅜ 아무리 생각해봐도 모르겠어서 다양한 방법을 참고했다.



