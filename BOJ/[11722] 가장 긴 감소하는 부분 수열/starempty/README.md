DP

DP배열: 현재 인덱스까지 가장 긴 감소하는 부분 수열의 길이를 넣어준다.

배열 탐색 방법
```python
for i in range(0, n):
    ans[i] = 1
    for j in range(i-1, -1, -1):
        if a[i] < a[j] and ans[i] <= ans[j]:
            ans[i] = ans[j] + 1
```
바깥 for문은 순서대로 진행하고 안쪽 for문은 현재의 직전 인덱스부터 0까지 감소하며 체크한다.

그때에 전 인덱스의 a배열 값이 단순히 큰 것만 고려하면 안되고, DP배열의 값이 크거나 같을 때를 고려한다.

(처음에는 ans[i] += ans[j]로 설계하여 DP배열을 덮어쓰고 break했는데 한 번 큰 값을 찾아서 break해 버렸을 때 그 전에 있을 수 있었던 ans가 더 큰값을 찾지 못하므로 그냥 그 전에 있는 모든 인덱스를 훝으며 하나씩 추가해주는 것이 해결방법이었다.) 

만약 n이 1이 들어온다면 가능한 부분집합의 갯수는 1임으로 1을 그냥 출력하면 된다.

<pre>
if 문 작성할 때 직전 노드가 더 커야한다는 것은 금방 발견했지만 DP배열까지 비교해야한다는 생각을 못했다. 아직 DP가 서툰 것이 많이 티가 난다.

질문검색 참고하여 풀었는데 어떤 답변에 n이 1인 경우 -300 출력하는 것이 틀렸다고 올린 것인데 그게 맞다고 생각해서 한참 고민했다. 문제를 제대로 생각하며 풀어야겠다...

for문으로 차례차례 탐색할 때에는 인덱싱을 잘 고려해야겠다.
</pre>