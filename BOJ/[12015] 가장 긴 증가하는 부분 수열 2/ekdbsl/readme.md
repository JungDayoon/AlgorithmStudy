# [BOJ 12015] 가장 긴 증가하는 부분 수열 - Python

### :computer: Algorithm

> DP, 이분탐색



### :computer: Logic

1. DP 풀이법
   - 현재 num과 이전의 값들의 비교하는데, 이전 값보다 현재값이 크다면 그 dp배열의 현재 값과, dp배열의 이전 값 + 1 중 더 큰 값으로 갱신한다.
   - dp의 최댓값이 답이다.
2. Binary Search 풀이법
   - LIS라는 빈 리스트에 number의 첫번째 원소를 넣는다.
   - LIS 리스트의 가장 마지막 원소와 number의 원소를 비교하는데, 이 때 number가 더 작다면 LIS의 마지막에 이 숫자를 append한다.
   - 만약 더 작은 숫자라면 이분탐색을 통해 이 숫자가 LIS 배열에서 어느 자리에 들어가야 할지를 찾는다. -> Lower bound
   - 이분탐색을 통해서는 LIS를 정렬된 상태로 유지하면서 이 숫자가 삽입될 수 있는 위치들 중 인덱스가 가장 작은 지점을 찾는다. 



### :computer: Review

이분탐색은 문제에 적용을 어떻게 하느냐를 생각해내는 것이 너무 어려운 것 같다..

다른사람들의 풀이를 참고해서 풀었다.

DP의 풀이방식은 시간복잡도가 O(N^2)이지만, 이분탐색의 풀이는 O(NlogN)이므로 훨씬 더 단축됐다.

