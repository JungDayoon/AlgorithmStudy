# [BOJ]/[9465] 스티커

## - DP -

> [Dynamic Programming]
>
> **큰 문제**를 풀기위해 **작은 문제**를 풀어 큰 문제를 해결하는 방법이다.
>
> +) '하나의 문제는 단 한번만 풀도록 하는 알고리즘!'
>
> +) 크고 어려운 문제를 먼저 잘게 나누어서 해결한 뒤에 처리하여 나중에 전체의 답을 구하는 것인데, 이 과정에서 '**Memoization**'이 사용된다는 점에서 분할정복과 다르다.

* `int[][] input`: `2N`개의 각 스티커의 점수 

* `int[][] dp`: 해당 index까지 얻을 수 있는 최고 점수

  * `dp[0][1] = input[0][1]`, `dp[1][1] = input[1][1]`로 초기화한다.

  * 2번째 열부터는 다음과 같이 구한다.

    ![image](https://user-images.githubusercontent.com/33208360/98361073-39043300-206e-11eb-80d4-b8b055e7ddd4.png)

    스티커 한 장을 떼면 변을 공유하는 스티커는 모두 찢어져 사용할 수 없으므로 위의 두 경우를 생각할 수 있다.

    ![image](https://user-images.githubusercontent.com/33208360/98367251-a7e68980-2078-11eb-96e9-6b8c5e186269.png)

    하지만, 위의 경우는 앞서 언급한 방식으로 구한다면 최고점수인 `200`을 낼 수 없다.

    따라서 아래처럼 구해주어야 한다.

    ```java
    dp[0][i] = Math.max(dp[1][i-1], dp[1][i-2]) + input[0][i];
    dp[1][i] = Math.max(dp[0][i-1], dp[0][i-2]) + input[1][i];
    ```

    (대각선 `dp`값과 2 index 전 대각선 dp값 중 최대값에 현재 index의 점수를 더한 값)

* index `n`까지 구한 후, `dp[0][n]`와 `dp[1][n]` 중 최대값을 출력한다.

</br>

## :speaking_head:

* dp문제를 많이 풀어보지 못해서 이 문제는 다른 사람이 푼 걸 참고해서 풀었다

  dp문제를 많이 풀어보도록 해야겠다