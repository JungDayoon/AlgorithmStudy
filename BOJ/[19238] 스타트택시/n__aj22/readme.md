# 백준 19238번 : 스타트택시

## Algorithm

Simulation, BFS


## Description

#### 기본로직

1. 손님이 남아 있으면 가장 가까운 손님을 찾아준다.

2. 손님 까지의 거리가 남은 연료보다 작거나 같으면 더 이상 진행 불가

3. 손님을 태운경우) 태운 손님의 목적지 까지 갈 수 없거나, 목적지 까지의 거리가 남은 연료보다 작으면 더 이상 진행 불가 


#### 함수설명

1. closestperson(nowi,nowj) : 현재 택시 위치인 nowi, nowj 에서 가장 가까운 손님의 위치 BFS로 찾아서 반환

+ 주의점 : 거리가 같은 경우 윗쪽, 왼쪽 손님 먼저
  + 따라서 손님을 만났다고 해서 바로 종료하는 것이 아니라 저장해두고 다음에 거리가 같은 손님을 또 만난다면 저장된 값과 비교해서 윗쪽, 왼쪽 손님을 먼저 태운다.
  + 큐를 빠져나오는 종료조건은 현재 큐에서 pop 된 제일 첫번째 요소 까지의 거리가 지금 찾아진 손님의 거리까지의 거리보다 크다면, 큐 안에는 모두 손님까지의 거리보다 긴 경우 밖에 없으므로 더 이상 확인할 필요 없이 종료한다.

    ``` python
       if(arr1[ni][nj]>0): # 사람이 존재한다면
           if(bestmove>=nmove): #움직임이 적으면
               if(besti>ni):
                   besti = ni
                   bestj = nj
                   bestmove = nmove
               elif(besti == ni):
                   if(bestj>nj):
                       bestj = nj
                       bestmove = nmove
    ```

2. riding(nowi, nowj, endi, endj) : 현재 손님을 태운 택시의 위치인 nowi, nowj 에서 손님의 목적지인 endi, endj 까지의 거리를 BFS로 찾아 반환해준다.

+ 주의점 : 목적지를 찾지 못할 수도 있다.

3. start_taxi(taxi_i, taxi_j, person_info, num) : 
+ 파라미터
  + taxi_i, taxi_j : 처음 택시 위치
  + person_info : 손님의 목적지 정보를 담고 있는 리스트
  + num : 태운 손님의 수
  
+ 전체 로직은 태운 손님의 수가 전체 손님 수인 M 보다 작거나 같을 동안 진행된다.

  a) closestperson 을 호출해서 가장 가까운 손님의 위치와 거리 확인
    
    a-1) 가장 가까운 손님까지 갈 수 없으면 -1
    
    a-2) 가장 가까운 손님 까지의 거리가 현재 남은 연료보다 크거나 같으면 -1
    
    a-3) 위의 두 경우에 해당하지 않는 경우 
        
        움직인 거리 만큼 연료를 빼주고, 그 위치로 택시 이동
        
        태운 손님의 번호를 확인하고, 그 손님의 목적지 위치 확인 후 b로! 
  
  b) riding 호출해서 목적지 까지의 거리 확인
  
    b-1) 목적지 까지 갈 수 없으면 -1
    
    b-2) 목적지 까지의 거리가 현재 남은 연료보다 크면 -1 
    
    b-3) 위의 두 경우에 해당하지 않는 경우
    
        현재 연료에 이동 거리만큼 더해주고, 그 위치로 택시 이동

        태운 손님의 수를 증가시켜줌
  
 
4. main

start_taxi(starti, startj, person_info, 1)


## Review

시간 초과 나서 힘들었지만 그래도 성공!   

