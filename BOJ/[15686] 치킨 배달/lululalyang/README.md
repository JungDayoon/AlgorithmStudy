# [BOJ]/[15686] 치킨 배달

## *- Simulation -*

**전역 변수**

`int Min = Integer.MAX_VALUE` : 도시의 치킨거리의 최솟값. 최대값으로 초기화

`int[][] map` : 도시의 정보

`ArrayList<int[]> chicken` : 각 치킨집의 위치 좌표 리스트

* `map`을 입력받으면서 치킨집이 있다면 리스트에 추가한다

## solution

1. **조합**을 이용해 모든 치킨집 중 `M`개를 남겨두고 어느 지점을 폐점시킬지 선택한다.

   치킨집의 개수를 `cSize`라고하면, `cSize`개 중에 `cSize - M`개를 조합으로 선택하여 폐점시킨다.

   `void Comb(int N, int r, int start, ArrayList<Integer> tmp)`

2. 폐점시킬 지점을 정했다면 그 지점을 폐점 시킨다. (`map`값을 `0`으로)

   `void CloseOrOpenStore(ArrayList<Integer> tmp, int flag)`

   : `tmp`에 있는 위치 좌표를 `flag`값으로 바꿔준다.

   `flag`가 `0`이면 폐점시키는 것, `2`면 다시 오픈하는 것.

3. 특정 지점을 폐점 시킨 후, 각각의 집의 치킨 거리를 BFS를 이용해 구하고, 그것을 통해 구한 도시의 치킨 거리를 `Min`값과 비교해 작은 값으로 `Min`값을 갱신한다.

   `void ComputeMinDist()`

   : 현재 상태의 도시 치킨거리를 계산

   `int bfs(int i, int j, int N)`

   : `(i, j)`위치의 집의 치킨거리를 계산

4. 모든 경우로 위 과정을 수행한 뒤의 `Min`값이 최종 결과값인 도시의 최소 치킨 거리값이 된다.

</br>

## :speaking_head:

> :timer_clock: ***40분***

쉽다. 근데 첫 시도에 *시간초과* 가 떴는데 2가지를 바꿔주었더니 통과했다.

1. BFS가 계속해서 수행되므로, `Queue`를 매번 할당해주는 것보다 하나를 선언한 후 `.clear()`해주면서 사용하는 것이 나을 줄 알았는데 아니였다.

   메모리 제한이 넉넉해서인지 매번 할당해주어도 메모리 초과가 생기지 않았고, 또 `.clear()`해주면 `Queue`에 있는 Element들을 다 `pop()`해주는 것이므로 많은 시간이 소모되는 것이었다.

   메모리 제한을 잘 확인하고 **`clear()`는 되도록 쓰지 말자 !!**

2. BFS를 하면서 상하좌우를 확인할 때 방문하지 않은 곳이라면 `q`에 추가해주고 `pop()`하면서 치킨집인지 확인하는 방식이었는데, 상하좌우를 확인하면서 치킨집이라면 바로 반복을 중단하도록 수정했다. 

=> 1번의 영향이 클 것 같긴 한데, 2번도 경우에 따라서 잘 처리해주자

