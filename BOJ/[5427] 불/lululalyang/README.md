# [BOJ]/[5427] 불

## *- BFS -*

**전역 변수** 

테스트케이스가 많기 때문에 공유할 수 있는 것은 모두 전역변수로 둔다

`String[][] map` : 입력받는 빌딩의 지도

`Queue<int[] > sangho` : 상호의 위치

* `"@"`의 좌표를 추가한다.

`Queue<int[]> fire` : 불의 위치

* `"*"`의 좌표를 추가한다.

`boolean[][] visited` : 상호의 방문여부

* `"@"`의 좌표의 `visited`배열값을 `true`로 바꿔준다.

## solution

> 매 테스트 케이스마다 `sangho`와 `fire`초기화 해주기!

**변수**

`int time = 0` : 상호가 탈출하기까지 걸리는 시간. `0`으로 초기화

`boolean flag = false` : 상호의 탈출 여부. `false`로 초기화

**로직**

상호가 탈출하거나, 갈 수 있는 곳이 없을 때까지 아래의 과정을 반복한다.

1. 상호는 불이 옮겨진 칸 또는 **이제 불이 붙으려는 칸**으로 이동할 수 없으므로, 불부터 상하좌우로 퍼트려준다.

   `void fireSpread(int w, int h)`

   * `int cnt = fire.size()` : 이전에 붙은 불의 개수
   * `fire`에서 `cnt`만큼만 뽑아내 그 불의 상하좌우로 불을 퍼트린다.
     * 이때, 상하좌우 중 빈공간인 곳으로만 불을 퍼트린다.
     * 빈공간이라면 `map`값을 `"*"`로 바꿔주고, 그 위치를 `fire`에 추가한다. (1초 뒤의 처리를 위함)
     * 불이 퍼지는 BFS는 `map`값으로 방문여부를 체크한다. (빈공간으로만 퍼지기 때문)

2. 불이 퍼진 뒤, 상호가 이동한다.

   `boolean MoveSangho(int w, int h)`

   : 상호의 탈출 여부를 리턴한다.

   * `int cnt = sangho.size()` : 마찬가지로 이전에 상호가 움직일 수 있었던 칸의 개수만큼만 확인한다.

   * `sangho`에서 `cnt`만큼만 뽑아내 그 위치의 상하좌우를 확인한다.

     * 빌딩 범위를 벗어난다면,

       탈출한 것으로 `true`를 리턴

     * 빌딩 범위 내라면, 

       빈공간일 경우에만 `sangho`에 그 위치를 추가하고, 방문여부를 `true`로 바꿔준다.

   * 탈출하지 못하면 `false`를 리턴

3. 시간을 늘려준다.  `time++`

4. 상호가 탈출 했다면 반복을 중단한다. => 그 때의 `time`값이 탈출하는데에 걸린 시간

5. 탈출하지 못했는데 갈 수 있는 곳이 없다면,

   즉 `sangho`큐가 비었다면 `time=-1`로 저장 후, 반복을 중단한다.

6. `time`값이 `-1`이라면 `"IMPOSSIBLE"`을, `-1`이 아니라면 `time`값 그대로를 출력한다.

</br>

## :speaking_head:

처음에 상호만 bfs로 이동시키고, 불은 그냥 새 배열을 만들거나, `q`를 이용하였는데 *메모리 초과* 파티였다 ..

이전에 상호의 방문 여부 체크를 해주지 않았어서 체크해주니까 *시간초과* 였다!

그래서 불 까지 bfs로 처리해주니까 통과할 수 있었다ㅜㅜ

