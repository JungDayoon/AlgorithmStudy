# [BOJ]/[11049] 행렬 곱셈 순서

## *- DP -*

* `int[][] dp`

  `dp[i][j]` : `i`번째부터 `j`번째 행렬까지 곱하는데 필요한 곱셈 연산의 최솟값

### solution

`int solution(int s, int l)` : `i`번째부터 `j`번째 행렬까지 곱하는데 필요한 곱셈 연산의 최솟값을 리턴한다. 즉, `dp[s][l]`값

1. `dp[s][l]`값이 `0`이 아니면, `dp[s][l]`값을 리턴

   : `dp[s][l]`값이 `0`이 아닌 것은 `s`번째에서 `l`번째까지의 곱셈연산 최솟값을 이미 구한것.

   => 똑같은 값을 다시 구하지 않고 구한값을 사용한다.

2. `(s+1) == l`이라면,

   `s`다음이 `l`인 것으로 행렬이 2개 => 이 두 행렬의 곱셈 연산 수를 리턴한다.

   (곱셈 연산 개수는 한 가지 경우뿐이다.)

3. `s == l`이라면, 

   행렬이 `s`번째 1개일 경우로, 곱셈연산 수는 `0`이다. => `0`을 리턴

4. 위 세 가지 경우가 아니라면, 아직 `s`번째에서 `l`번째까지 행렬곱 연산수 최솟값을 구하지 않은 경우.

   * 우선 `dp[s][l]`값을 최대값으로 초기화한다.

   * `s`에서 `l`까지의 행렬을 두 부분으로 나눌 수 있는 모든 경우로 나누어서 그때의 연산수 최솟값을 `dp[s][l]`값에 저장한다.

     `dp[s][l] = Math.min(dp[s][l], solution(s, i) + solution(i+1, l) + m[s].r*m[i].c*m[l].c)`

     (`s <= i < l`)

   > 이때, 두 가지로 나눌 수 있는 모든 경우를 고려해주어야 함!
   >
   > * (처음 행렬 + 나머지 행렬) / (마지막 행렬 + 나머지 행렬) 이런 식으로 하면 오답.
   >
   > * 반례
   >
   >   ```
   >   8
   >   1 100
   >   100 1
   >   1 100
   >   100 1
   >   1 100
   >   100 1
   >   1 100
   >   100 1
   >   ```

5. `dp[s][l]`값을 리턴

</br>

## :speaking_head:

* **BOJ_11062 카드게임**을 먼저 풀고 난 후, 이 문제를 풀어서 Top-down개념으로 좀 더 생각해주기 수월했다.
  * 처음에는 **11062**번 처럼, 양 끝 카드만 마지막에 더해주면 된다고 생각했는데, 위에 적어 둔 반례를 통해서 오답이라는 것을 알았고, 모든 경우를 다 해주어야된다는 것을 알았다 !
* Top-down 많이 풀어보잣!!