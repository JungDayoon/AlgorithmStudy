# [BOJ]/[16236] 아기 상어

## *- Simulation, BFS -*

**전역 변수**

`int[][] map` : 입력받는 상태 정보

`Shark shark` : 상어의 정보. (위치좌표, 크기, 먹은 물고기 개수) 를 저장한다.

`int[] dx, dy` : BFS시 사용될 상하좌우 이동크기

## solution

`int time = 0` : 아기상어가 엄마한테 도움을 요청하지 않고 물고기를 잡아먹을 수 있는 시간. => 최종값!!

* BFS를 사용해 먹을 수 있는 가장 가까운 물고기, 그 중에서도 가장 위쪽의 왼쪽에 있는 물고기를 찾는다.

  Queue대신 PriorityQueue를 사용한다.

  `PriorityQueue<Element> pq` : 물고기까지의 거리를 우선으로 오름차순, 거리가 같다면 `x`좌표가 작은 순으로, `x`좌표도 같다면 `y`좌표가 작은순으로 정렬되도록 한다.

  * `class Element` : 위치 좌표와 이동거리를 저장

1. 상어의 첫 위치와 이동거리 `0`을 `pq`에 추가한다.

   > 매번 해줄때마다 `pq`초기화와 방문여부 체크용 배열인 `visited`를 새로 할당해준다.

2. bfs를 이용해 가장 가깝고, 가장 위쪽이면서 왼쪽인 먹을 수 있는 물고기의 위치를 찾는다.

   * 이 때 방문하지 않았던 칸이면서, 값이 상어의 크기보다 작거나 같은 칸으로만 이동시킨다.
   * 물고기 찾으면 그 위치를 따로 저장하고 `break`

3. 만약 먹을 수 있는 물고기를 찾았다면, 

   * `time`에 그 물고기까지의 이동거리를 더한다. (한칸 이동할 때마다 1초가 걸리므로)
   * 그 위치의 물고기를 없애고 , 상어가 먹은 물고기 개수를 `+1`해준다.
   * 상어의 위치도 옮긴다. 

   위 처리를 다 해준 후, 만약 상어가 먹은 물고기 개수가 상어의 크기와 같다면,

   * 상어의 크기를 `1`만큼 늘려주고, 먹은 물고기 개수를 다시 `0`개로 바꾼다.

   => 이동시킨 상어의 위치로 다시 1번 과정부터 진행한다.

4. 만약 먹을 수 있는 물고기가 없다면,

   엄마 상어에게 요청해야하므로 반복을 중단한다. => **이 때의 `time`이 결과값** 

</br>

## :speaking_head:

> **:timer_clock: *01:10 ~ 2:10***

* 처음엔 bfs에 사용되는 `int[] dx, dy`배열의 순서를 :arrow_up:, :arrow_left:, :arrow_right:, :arrow_down: 으로 설정해주고 bfs를 했는데 테케4번의 결과값이 계속 달랐다

  * 디버깅해보니까 ![image](https://user-images.githubusercontent.com/33208360/115103109-3fd29280-9f8a-11eb-8c8d-3e248a89ce91.png)

    위의 상태로 파란색에 상어가 있고, 노란색에 먹을 수 있는 물고기가 있을 때,

    일반 Queue를 사용하면 `dx, dy`배열을 위 같이 설정해주어도 1번 물고기부터 먹게된다.

    그렇지만 2번 물고기가 1번물고기보다 위에있으므로 먼저 먹어야 한다!!

  * 그래서 우선순위 큐를 사용하여서 했다

* 위치 우선순위가 있다면 간편하게 우선순위 큐를 사용하자 !!!