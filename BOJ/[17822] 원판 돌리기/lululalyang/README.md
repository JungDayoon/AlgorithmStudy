# [BOJ]/[17822] 원판 돌리기

## *- Simulation -*

* `circles[i][j]` : (`i`, `j`) 위치에 있는 숫자
  * `circles[i][j] = 0` : 숫자가 없는 것을 의미한다
* `int[][] rotate` : 회전 정보
  * `rotate[i][0]` : `xi`
  * `rotate[i][1]` : `di`
  * `rotate[i][2]` : `ki`

### solution

* `int res` : `T`번 회전 후 남은 숫자의 합 (결과값)

* `T`번 회전할 동안 아래 과정을 반복한다.

1. 만약, 첫 회전이 아니라면 숫자가 남아있는지 확인한다.

   `boolean ChkRemain(int N, int M)`

   : `circles[i][j]`가 `0`이 아닌 숫자가 있다면 아직 숫자가 남아있는 것

   * 남아있지 않다면, `res = -1`

2. 숫자가 남아있다면, `x, d, k`에 맞춰 원판을 회전시킨다.

   `void RotateCircles(int x, int d, int k, int M)`

   * `int[] now = circles[x]` : `x`번째 원판의 정보

   * `int[] res = new int[M]` : `x`번째 원판을 회전시킨 후의 원판 정보

   1. `d == 0`이라면(시계방향이라면),

      `res[i+k]`에 `now[i]`값을 저장한다.

      * 이때, `(i+k)`값이 `M`보다 크거나 같다면, `res[i+k-M]`에 `now[i]`값을 저장한다.

   2. `d == 1`이라면(반시계방향이라면),

      `res[i-k]`에 `now[i]`값을 저장한다.

      * 이때, `(i-k)`값이 `0`보다 작다면, `res[i-k+M]`에 `now[i]`값을 저장한다.

   3. 숫자를 다 회전시킨 후에 `circles[x] = res`로 `x`번째 원판의 정보를 바꿔준다.

3. 회전시킨 후, 인접하면서 같은 수가 있는지 확인하고, 있다면 `0`으로 바꿔 숫자를 없앤다.

   * `int sum` : 인접하면서 같은 수가 없을 때, 남은 숫자의 합
   * `int cnt` : 인접하면서 같은 수가 없을 때, 남은 숫자의 개수

   => `sum`과 `cnt`는 인접하면서 같은 수가 없을 때, 평균값을 구하기 위해 계산해둔다.

   * `int Adjcnt` : 인접하면서 같은 수가 있으면 양수, 없다면 `0`

   1. 원판을 스캔하면서 만약 숫자가 존재한다면 (`circles[i][j] != 0`), 인접한 숫자를 확인하고 값이 같은 숫자가 있다면 모두 `0`으로 바꿔준다.

      `int ChkAdjSameNum(int x, int y, int N, int M)`

      * `int cnt = 0` : `(x, y)`와 인접하면서 같은 숫자의 개수

      1. 현재 위치 (`x`, `y`)를 기준으로 인접한 위치에 있는 숫자를 확인한다.

         * 인접한 위치
           1. `circles`배열 상에서 상하좌우에 있는 숫자라면 인접한 숫자.
           2. 만약 `y=0`이면, 해당 원판의 처음에 있는 숫자이므로 마지막 숫자인 `circle[x][M-1]`과 인접해있다.
           3. 만약 `y=M-1`이면, 해당 원판의 마지막에 있는 숫자이므로 첫번째 숫자인 `circle[x][0]`과 인접해있다.

         * 만약, 인접한데 같은 수가 있다면 `q`에 위치를 `add()`해두고, 그 위치의 숫자를 없앤다. (`circle[rx][ry] = 0`)
           * `cnt++`

      2. `cnt`값이 `0`이 아니라면, 바로 인접해있는 같은 수가 있는 것

         => `(x, y)`위치의 숫자도 없앤다.

         * `(x, y)`와 바로 인접해있는 같은 수는 다 확인했으므로, `q`에 추가해주지 않는다.

      3. `q`가 빌 때까지 `poll()`하면서, 그 위치와 인접하면서 같은 수가 있다면 없애고 `q`에 추가해준다.

      4. `cnt`값을 리턴한다.

4. 인접한 같은 수가 없다면(`Adjcnt == 0`), 

   계산해둔 `sum`과 `cnt`로 평균을 구하고, 그 평균값으로 원판의 숫자를 조정한다.

   `void AdjByAvg(float avg, int N, int M)`

   : 원판의 숫자를 스캔하면서

   * `avg`보다 큰 수라면, `+1`
   * `avg`보다 작은 수라면 `-1`

5. `T`번 회전 후,

   * `res == -1`이라면, `T`번 회전 전에 모든 숫자를 없앤 경우로 `0`을 리턴한다.

   * 그렇지 않다면, 원판에 남은 숫자의 합을 계산해 리턴한다.

     `int RemainNumSum(int N, int M)`

     : 남은 숫자 합 계산

</br>

## :speaking_head:

처음에 마지막 테케가 틀려서 오류를 한참 찾았는데, 배열 범위 체크를 잘못해주고있었다ㅜ 처음에 배열을 다른 방식으로 저장했었는데 배열 방식을 바꾸면서 `Valid`메소드까지 바꿔주지 않았던 것같다 .. 디버깅 전에 구현 한번 더 확인하고 해보자



