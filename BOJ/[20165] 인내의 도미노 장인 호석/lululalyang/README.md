# [BOJ]/[20165] 인내의 도미노 장인 호석

## *- Simulation -*

**전역변수**

* `int[][] height` : 입력받는 도미노의 높이

* `String[][] state` : 도미노의 상태. 세워져있으면 `"S"`, 넘어져있으면 `"F"`.

  * 처음엔 모두 세워져있으므로 `"S"`로 초기화한다.

* `int[] dx, dy` : 방향에 따라 이동하기 위한 값으로, 인덱스 값에 따라 `0`은 북쪽(`E`), `1`은 동쪽(`E`), `2`는 남쪽(`S`), `3`은 서쪽(`E`)을 나타낸다.

  * 공격 방향이 `String`으로 입력되기 때문에 이에 맞는 `Integer`값을 구해 활용한다.

    `int DirToInt(String dir)` : 방향에 맞는 인덱스를 리턴

## solution

**변수**

* `int score = 0` : 공격수의 점수 총합. 즉, 공격수가 넘어뜨린 도미노 개수

**로직**

* 라운드 개수 `R`을 줄여주면서 `R`이 `0`이 될 때까지 아래 과정을 반복한다.

1. 공격 좌표와 방향에 맞춰 도미노를 넘어뜨린다.

   `int AttackDomino(int ax, int ay, int adir, int N, int M)`

   * `Queue`를 사용.

     `q`에는 넘어뜨리는 도미노의 위치좌표를 저장한다.

     공격수가 넘어뜨리는 위치를 `q`에 추가.

   * `q`에서 위치를 하나씩 뽑으면서 `q`가 빌 때까지 아래의 과정을 반복한다.

     1. 현재 위치의 도미노가 넘어져있다면, 연쇄적으로 넘어지는 도미노도 없으므로 `continue`

     2. 세워져있다면 넘어뜨리고,

        현재 도미노의 높이를 `h`라고 할 때, 공격수가 넘어뜨린 방향의 `h-1`개 만큼 도미노의 위치를 `q`에 추가한다.

        * 이때, 그 위치의 도미노가 넘어져있다면, 그 도미노로 연쇄되는 것이 없으므로 추가해주지 않는다.

     3. `q`에서 뽑는 위치가 공격수가 넘어뜨리는 도미노의 위치이므로, 이 때마다 개수를 세어 준다.

   * 넘어뜨린 도미노 개수를 리턴.

2. 리턴 받은 개수를 `score`에 더해준다.

3. 수비수가 세우는 위치의 도미노를 다시 세워준다.

4. 라운드가 끝난 후, `score`의 값이 공격수의 점수 총합.

</br>

## :speaking_head:

공격수가 공격하는 위치의 도미노도 상태를 확인해주어야한다.

* 넘어져있다면 연쇄되어 넘어지는 도미노도 없으므로

공격수의 위치의 도미노는 확인해주지않아서 2개만 맞았는데, 이 부분 처리해주니까 통과했다 ! 꼼꼼하게 확인하쟛

