# [BOJ]/[2293] 동전 1

## *- DP -*

#### Solution

1. `int[] coin` : 동전 종류를 담은 배열

   => 이 배열을 오름차순으로 정렬해준다.

2. `int[][] dp = new int[N][K+1]`

   `dp[x][y]` : `coin[x]` 동전 하나를 추가해서 `y`원을 만들 수 있는 경우의 수

   * `dp[0][0]` : `0`원을 만드는 경우의 수를 `1`로 초기화 해준다.
   * 최종적으로 `dp[0][K] + ... + d[N-1][k]` 값이 `K`원을 만들 수 있는 경우의 수가 된다.

3. `dp[i][j]`를 계산해준다. (`i` : 동전 종류 인덱스, `j` : `j`원 인덱스)

   1. 현재 동전의 가치를 저장해둔다.

      `int nowC = coin[i]`

   2. `int value = j - nowC`를 저장해두고, 이 `value`값이 `0`보다 크거나 같은지 확인한다. ( `if(value >= 0)`)

      * 만약 조건을 만족하면 `dp[i][j] = SUM(dp[k][value])` (`0 <= k <= i`)

      * `dp[][value]`값을 모두 더한 값은 같은 조합이지만 순서가 다른 조합 즉, 이 문제에서 같은 경우로 포함되는 겹치는 경우가 존재한다.

      * 겹치는 경우가 생기지 않게 하기 위해서 현재 동전의 가치보다 작거나 같은 가치의 동전을 사용한 경우에만 해당 동전을 더해준 경우의 수를 구한다. ( 가치가 작은 동전에서 처리하지 않은 부분은 후에 가치가 큰 동전에서 처리된다. )

        => 이를 처리하기 위해 `coin`배열을 오름차순 정렬해주었다.

4. `SUM(dp[i][K])` (`0 <= i < N`) 값이 `K`원을 만들 수 있는 경우의 수. 이 값을 리턴한다.

## :speaking_head:

* 처음에는 겹치는 조합의 처리때문에 가능한 동전 조합을 리스트로 해서 모두 저장하려 했는데, 메모리 제한이 작아 다시 생각해보았다.
* 리스트가 어떻게 더해지는지 차근차근 확인해보니 나름 규칙이 금방 찾아졌다 !