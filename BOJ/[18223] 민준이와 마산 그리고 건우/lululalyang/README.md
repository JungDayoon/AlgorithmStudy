# [BOJ]/[18223] 민준이와 마산 그리고 건우

## *- Dijkstra -*

* `ArrayList<Integer>[] parents`: 최단거리 경로의 각 노드의 부모노드를 담는 배열리스트

  * 최단거리의 경로가 2개 이상이라면 부모 노드가 여러 개가 될 수 있으므로 리스트로 저장

* `ArrayList<Edge> adj`: 인접리스트. 양방향 그래프이므로 edge는 양쪽 노드 모두에 이어 줌

* `PriorityQueue`를 이용해 다익스트라를 구현.

  *  만약 최단 거리가 갱신된다면, `pq`에 `add`해주고, `parent[next.v]`를 아예 없애고 다시 현재의 부모노드 `now.v`를 `add`해준다.
  * 만약 어떤 노드를 거쳐서 가는 경로의 최단거리가 기존의 최단거리와 같다면 경로가 여러 개일 수 있는 거니까 현재의 부모노드 `now.v`도 `add`해준다.

* `void findGeonWoo(int here, int P)`  => DFS함수!

  : 최단 경로를 목적지에서부터 거꾸로 따라가며 건우가 있는지 확인하는 메소드

  * `static int flag = 0`: 전역변수. 건우가 있으면 `1`로 값을 바꿔 줌

  * `int here`: 현재 위치하고 있는 노드 번호
  * `int P`: 건우의 위치

  * 만약 `here == 1`이라면 출발지까지 온거니까 `return`
    * 근데, 건우가 출발지에 있을 수도 있으니까 `here==P`라면 `flag`값을 `1`로 바꿔준 후 `return`
  * 출발지까지 오기 전에 건우를 찾으면 ( `here == P` ) `flag` 값을 `1`로 바꿔주고 `return`
    * 문제상에서 1->V, 1->P까지의 경로는 무조건 존재한다는 조건이 있기때문에 가능
  * 위 두 조건에 맞지 않는 노드라면 그 노드의 부모노드를 탐색해  `findGeonwoo(부모노드, 건우 번호)`를 호출한다.
    * 부모노드의 개수만큼 반복하는데 하나의 부모노드를 통해 건우를 찾았을 경우 남은 부모 탐색하지 않고 `return`한다

* `flag == 1`이면 "SAVE HIM"을, 그렇지 않다면 "GOOD BYE"를 출력한다.

</br>

## :speaking_head:

건우가 출발지의 있을 경우와 더 작은 최단거리가 생기면 원래있던 부모노드들을 없애준 후 다시 붙여줘야하는 것을 생각하지못해 틀렸었다!

처음부터 생각나면 좋겠지만 ,, 😉

