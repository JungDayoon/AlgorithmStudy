# [BOJ]/[1300] K번째수

## 분류
이분탐색

## 접근법
세준이는 크기가 N×N인 배열 A를 만들었다. 배열에 들어있는 수 A[i][j] = i×j 이다. 이 수를 일차원 배열 B에 넣으면 B의 크기는 N×N이 된다. B를 오름차순 정렬했을 때, B[k]를 구해보자
 - 여기서 일단 2차원배열에 i * j가 들어있든 중요하지 않다.<br>
 - 이 문제의 핵심 아이디어는 일차원 배열을 정렬했기 때문에 어떤수 answer보다 작은거나 같은 수의 갯수가 k가 되는 지점이 바로 B[k]이라는 것이다.<br>


## 예제
N = 3<br>
K = 7<br>

- 2차원 배열<br>
　　　1　2　3 <br>
A = 1 [1][2][3]<br>
　　2 [2][4][6]<br>
　　3 [3][6][9]<br>

- 1차원 배열<br>
A = [1][2][2][3][3][4][6][6][9]<br>
　　　　　　　　　　　　^ <br>
A[7] = 6




## answer보다 작거나 같은 수 구하기
이제 answer를 구해야하는데<br>
이때 이 배열의 특이한 성질을 이용해야한다.(이건 생각해낼 수 없으므로 외우기)<br>

- 만약 N=10 일 때,<br>
- [1 * 1][1 * 2][1 * 3][1 * 4][1 * 5][1 * 6][1 * 7][1 * 8][1 * 9][1 * 10]<br>
여기서 7보다 작은 수가 몇개 일까?<br>
7//1 = 7개이다.<Br>

- [2 * 1][2 * 2][2 * 3][2 * 4][2 * 5][2 * 6][2 * 7][2 * 8][2 * 9][2 * 10]<br>
여기서 7보다 작은 수가 몇개 일까?<br>
7//2 = 3개이다.<br>
>1. 각 값을 i(여기선 2)로 나누어서 생각하는 것이다.<br>
>2. 그럼 배열의 숫자들은 1~10까지 숫자가 되고<br>
>3. answer(여기선 7)도 i로 나누어주면 (//로 나누면 몫만 나옴) 3이 나온다.<br>
>4. 이말은 2*3+나머지(=7) 보다 작거나 같은 수는 2 * 1,2 * 2,2 * 3 이란 말이 되기 때문에 7보다 작은 수는 몫인 3이된다.<br>

- 여기서 또 중요한건 100보다 작은 수 는 몇개일까?<br>
100//2 = 50개가 아니라 최대 갯수인 N개이다.<br>
>그래서 갯수를 구할 때 min(answer//i,N) <br>
>즉,answer//i가 N을 넘으면 N을 갯수로 더해야 한다.<br>

- 이걸 확장하면 2차원 배열에서 모든 열을 돌면서 (for i in range(N))
- sum(answer//i)==K이면 
- answer이 이문제의 정답이 된다.
```python
sum = 0
for i in range(1,N+1):
    sum+=min(N,answer//i)
```


### 이제 마지막 이분탐색
여기서 이제 answer를 이분탐색으로 찾는거다.

```python
start = 0, end = N*N
while start <= end:
    mid = (start+end)//2
    sum = 0
    for i in range(1,n+1):
        sum+= min(mid//i,n)
    if sum>=k:
        answer = mid
        end = mid-1
    else:
        start = mid+1
```
- 만약 mid_num 보다 작거나 같은수의 갯수(sum)이 k보다 크거나 같으면 end_num = mid_num-1로 해주면서 start<=end 일 때까지 탐색한다.
- sum이 k보다 크거나 같을 때 answer를 지정해 주는 이유
>- N=3일때 (위의 예제) 6보다 같거나 작은 수는 8개이다. (8번째 수가 6)
>- mid==5 일 때 sum = 6
>- mid==6 일 때 sum = 8
>- 5보다 같거나 작은 수는 6개 이기 때문에 answer가 "확실히" 아님을 알 수 있음
>- 즉, sum이 k보다 클 경우도 답이 될 수 있음. (같은숫자가 많을경우)





## 후기
이분탐색 정리<br>
다시봐도 토나올거같다<br>
마크다운 띄워쓰기(　)<-복사<br>