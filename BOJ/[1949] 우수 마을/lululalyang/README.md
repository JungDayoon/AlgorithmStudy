# [BOJ]/[1949] 우수 마을

## *- TreeDP -*

* `ArrayList<Integer>[] adj` : 인접 리스트
* `ArrayList<Integer>[] tree` : 트리
* `int[] citizen` : 각 마을의 주민 수
* `int[][] dp` 
  * `dp[i][1]` : `i`를 루트로 하는 서브트리에서 **`i`가 우수마을일 때**의 우수마을의 주민 수의 최대 총합
  * `dp[i][0]` : `i`를 루트로 하는 서브트리에서 **`i`가 우수마을이 아닐 때**의 우수마을의 주민 수의 최대 총합

### solution

* `dp[i][0]` : `i`가 우수마을이 아닐 때

  * `i`의 자식노드는 우수마을이여도 되고, 아니여도 됨.

  :heavy_plus_sign: 모든 자식노드가 우수마을이아닌 경우도 포함!

  > 확실하지 않지만, **주민 수 최대**를 구하는 것이므로 모든 자식노드가 우수마을이 아닌 경우도 <조건 3. 우수마을로 선정되지 못한 마을은 적어도 하나의 우수마을과는 인접해 있어야 한다> 을 만족하기 때문에 (적어도 하나의 우수마을과는 인접!) 고려해주어야 한다고 생각.

  * 따라서, `dp[i][0]`은 자식노드가 포함되거나 포함되지 않는 모든 경우를 조합으로 구한 후, 최대 주민 수를 저장한다.

* `dp[i][1]` : `i`가 우수마을일 때,

  * <조건 2>를 만족해야 하므로, 모든 자식노드는 우수마일이어서는 안된다.
  * `dp[i][1] = SUM(dp[k][0])` (`k`는 `i`의 자식노드)

* **dfs** 사용