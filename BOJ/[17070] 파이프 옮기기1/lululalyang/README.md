# [BOJ]/[17070] 파이프 옮기기 1

## *- DFS -*

* ```java
  int[][] checkBydir_x = {{0}, {1}, {0, 1, 1}};
  int[][] checkBydir_y = {{1}, {0}, {1, 1, 0}}; 
  ```

  : 이동방향(index)에 따라 파이프 오른쪽 끝 위치를 기준으로 확인해줘야하는 좌표까지의 변화량

  index `0`: :arrow_right:	index `1`: :arrow_down:	index `2`: :arrow_lower_right:

* ***in `main`***

  * `int px = 0, py = 1` : 파이프 오른쪽 끝의 시작점 x, y 좌표

  * `int pipe`: 파이프의 모양. 처음엔 가로모양이다

    ​		value `0`: 가로모양, value `1`: 세로모양, value `2`: 대각선 모양

  * `dfs(px, py, pipe)`호출

    </br>

* `void dfs(int px, int py, int pipe)`

  : 파이프의 모양과 이동방향에 따라 좌표를 이동시키면서 `map`의 오른쪽 끝에 도착하면 이동시키는 방법의 개수인 `result` 를 1씩 늘려준다.

  * 파이프의 모양 `pipe`에 따라 이동할 수 있는 방향이 다르다.

    가로모양(`0`): :arrow_right:, :arrow_lower_right:	세로모양(`1`): :arrow_down:, :arrow_lower_right:	대각선모양(`2`): :arrow_right:, :arrow_down:, :arrow_lower_right:

    이동방향에 맞는 value값과 함께 `movePipe()`를 호출한다.

    예) 파이프가 가로모양일 때

    ```java
    movePipe(px, py, pipe, 0); // →
    movePipe(px, py, pipe, 2); // ↘
    ```

    </br>

* `void movePipe(int x, int y, int pipe, int moveDir)`

  : 현재 위치와 파이프의 모양, 이동방향에 따라, 다음 위치가 이동가능한 위치인지 확인하고, 이동가능하면 그 좌표로 다시`dfs()`를 호출한다.

## :speaking_head:

처음에는 무작정 bfs로 풀었는데 *시간초과* 가 났다. dfs로 바꿔서 푸니까 풀렸다!

아직 어떨 때 dfs를 써야하고 bfs를 써야하는 지 잘 모르겠다 .. 공부하자 !

>  ***[ bfs(너비우선탐색) ]*** => " 최단경로 ! "
>
> <u>장점)</u> 
>
> ​	1) 너비를 우선으로 탐색하기 때문에 답이 되는 경로가 여러 개인 경우에도 **최단경로**임을 보장.
>
> ​	2) 최단경로가 존재한다면, 어느 한 경로가 무한히 깊어진다 해도 최단경로를 반드시 찾을 수 있다.
>
> ​	3) :star:**노드의 수가 적고**, **깊이가 얕은 해가 존재**할 때 **유리**.
>
> <u>단점)</u>
>
> ​	1) 큐를 사용해 다음에 탐색할 노드를 저장하기 때문에 노드의 수가 많을수록 필요없는 노드들까지 저장해야하기 때문에 **큰 저장공간 필요**. (java에서 Queue구현할 때, LinkedList를 사용하는데 이때, 노드가 많다면 add()하고 poll()하는 데에도 **시간 오래 걸림**!)
>
> ​	2)  노드의 수가 늘어나면 탐색해야하는 노드 또한 많아지므로 비현실적
</br>

> ***[ dfs(깊이우선탐색) ]*** => " 깊은 단계에 있을 때 ! "
>
> <u>장점)</u>
>
> ​	1) 비교적 저장공간의 필요성이 적다. 백트래킹해야하는 노드만 저장해주면 된다.
>
> ​	2) :star:**찾아야하는 노드가 깊은 단계에 있을수록**, BFS보다 **유리**.
>
> <u>단점)</u>
>
> ​	1) 답이 아닌 경로가 매우 깊다면, 그 경로에 깊이 빠질 우려가 있다.
>
> ​	2) 지금까지 찾은 최단경로가 끝까지 탐색했을 때의 최단경로가 된다는 보장이 없다.
