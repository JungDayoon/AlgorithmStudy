# [BOJ]/[17136] 색종이 붙이기

## *- BackTracking -*

**전역 변수**

```java
int Min = Integer.MAX_VALUE; // 붙여야 하는 색종이 개수
int[] paper = {0, 5, 5, 5, 5, 5}; // 색종이 크기별 남아있는 장 수
```

* `Min` 값은 최대값으로 초기화
* `paper`의 인덱스가 색종이 크기. 예) `paper[1]` : 1x1 크기의 색종이 남은 장 수

## solution

백트래킹 함수

```java
void backTracking(int[][] prev, int x, int y, int cnt)
```

* `prev` : 칸의 이전 상태
  * `0`은 빈칸, `1`은 색종이로 덮어야 하는 칸, `2`는 색종이를 놓은 칸
* `x`, `y` : 이때까지 확인한 칸의 마지막 인덱스
* `cnt` : 이떄까지 사용한 색종이 개수

1. `prev`를 `x`행부터 스캔하면서 `1`이 있는 칸을 찾는다. => `int i, j` (`i`:행 번호, `j`: 열 번호)

2. 남은 `1`이 없다면, 그 때까지 사용한 색종이 개수 `cnt`로 `Min`값을 갱신하고 `return`한다.

3. 남은 `1`이 있다면,

   그 위치를 시작점(가장 위쪽, 왼쪽 꼭짓점)으로 해서 5종류의 색종이를 놓을 수 있는지 확인한다.

   1) `paper[size]>0` : 이 크기의 남은 색종이가 있는지

   2) `boolean CheckValid(int[][] map, int x, int y, int size)` : 문제에서 주어진 조건에 맞는지

   * `(x, y)` 부터 `(x+size, y+size)`까지의 칸을 확인
   * 경계 밖이면 색종이 놓을 수 없다 => `false` 리턴
   * 색종이끼리 겹치거나, `0`이면 놓을 수 없으므로 `1`이 아니면 `false` 리턴
   * 정해진 범위 내 모든 칸이 위 2가지 조건을 만족한다면 `true` 리턴

4. 현재 크기의 색종이를 놓을 수 있다면, 그 범위에 색종이를 놓고 (`2`로 변경) `paper[size]`배열의 값을 `1` 줄여준다.

   이 상태에서 사용한 색종이 개수를 `1` 늘려 백트래킹 함수 호출.

5. 호출한 뒤 놓았던 색종이를 다시 뺀다. `paper[size]`배열의 값도 다시 `1` 늘려준다.

   이 상태로 다음 크기의 색종이를 확인한다. (3번과정으로)