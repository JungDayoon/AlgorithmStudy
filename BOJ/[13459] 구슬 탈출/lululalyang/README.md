# [BOJ]/[13459] 구슬 탈출

## *- BFS -*

####  Main

* `String[][] map` : 보드의 정보를 저장
  * `R`과 `B`의 위치 좌표는 `int[] R`, `int[] B`에 저장하고, `map`값을 `"."`로 바꿔 저장한다.

#### class

* `class TwoMarbles` : 빨간 구슬과 파란구슬의 좌표와 이동 횟수를 저장한다.
* `class Marble` : 구슬 하나의 좌표, 탈출 여부, 이동 횟수를 저장한다.

#### Func

* `int CanEscape(Queue<TwoMarbles> q)`

  : 이동 **10회 이하**로 빨간 구슬만이 탈출할 수 있으면 `1`을, 탈출할 수 없다면 `0`을 return한다.

  * bfs이용

    * `q`에는 빨간 구슬과 파란 구슬, 두 구슬 모두의 좌표와 이동횟수를 저장한다.

  * `q`에서 꺼낸 현재 구슬들의 위치에서 각 4방향으로 이동시킨다.

    * 이때, 각각 구슬별로 이동시킨다. => `class Marble`객체 이용

      `void MoveMarble(Marble now, int d)`

      : 장애물 `"#"`를 만나기 전까지 방향 `d`에 따라 구슬을 이동시킨다.

      * 이동 중 구멍 `"O"`을 만난다면 `now.escape = true`처리해준 후 `return`한다.

  * 두 구슬을 이동시킨 후, 만약 두 좌표가 같다면 위치를 조정시킨다. (구슬 하나의 크기는 map의 한 칸을 가득채우므로 한 칸에는 구슬 하나만 존재할 수 있다.)

    `void AdjustRB(Marble R, Marble B, int dir)`

    : 현재 이동 방향 `dir`에 따라 더 뒤에 있던 구슬의 위치를 한칸 뒤로 옮겨준다.

    * 조정한 좌표가 이동 전 좌표와 같다면 => 이동하지 못한 것이니까 이 경우는 **패스**
    * 조정한 후, 위치가 바뀐 구슬은 이동 횟수인 `moveCnt`를 `1` 줄여주고, 만약 이전 위치가 구멍이었다면 `escape`를 다시 `false`로 바꿔준다.

  </br>

  * 위의 모든 처리를 해준 다음, 구슬 `B`가 탈출했거나, 둘 다 움직이지 않았다면 이 경우 **패스**
  * 만약, 구슬 `R`만 탈출했다면 `flag=true`로 바꿔주고 `1`을 리턴한다
  * 둘 다 탈출하지 못한 경우에는 다음 이동을 위해 `q`에 현재 위치와 `cnt+1`을 `add()`해준다.

  </br>

  * `q`가 빌 때까지 위 과정을 반복

    * 만약 `cnt == 10`이라면 `break` 

      ( 이동시키고나서 `cnt+1`해주므로 `cnt==10`이라면 이미 10번 이동한 것! 이후 이동은 11번째 이동이 된다.)

## :speaking_head:

* 처음에는 빨간 구슬과 파란 구슬의 좌표를 따로 처리하고 구슬의 이동도 bfs를 사용하여 풀었는데, 두 좌표를 따로 관리하기 어려워서 그런지 틀렸었다.

* 그래서 두 좌표를 한 객체에 함께 저장했더니 더 맞긴 했지만 또 통과되지 못했다 .. 코드를 다시 보니 알고보니까 `cnt == 11`일 때 반복문을 `break`해줬어서 이전 코드는 11번째 이동까지 가능했던 것이다😭😭 

  종료 조건 잘 확인해주도록 하자 ..!!!!!!!!!!!