# [BOJ]/[19236] 청소년 상어

## *- Simulation, BackTracking -*

**전역 변수**

```java
int Max = 0; // 최종 결과값. 상어가 먹을 수 있는 물고기 번호 합의 최대값.
int[] dx, dy; // 방향별 이동값. 문제에서 주어지는 방향의 인덱스와 동일하게 저장.
```

## solution

***In Main***

```java
Fish[] fish = new Fish[17]; // 각 물고기의 위치, 방향 정보 배열
int[][] map = new int[4][4]; // 배열의 각 위치에 있는 물고기의 번호
```

* 주어지는 정보를 입력받으면서 `fish`배열과 `map`을 채운다.

위를 통해 `(0, 0)`에 있는 물고기의 번호를 상어가 먹은 물고기의 번호로, 물고기의 방향을 상어의 방향으로 설정한다.

```java
boolean[] live = new boolean[17]; // 1번 ~ 16번 물고기의 살아있는지 여부
```

* `(0, 0)`에 있던 물고기는 잡아먹혔으므로 `live`값을 `false`로 설정.

상어의 위치와 방향, 상어가 먹은 물고기 번호의 합, 물고기 정보를 인자로 `BackTracking()`메소드를 호출한다.

***In Method - `void BackTracking(int sx, int sy, int sd, int sum, Fish[] prev, boolean[] live)`***

1. 현재 상태에서 사용할 맵 물고기의 정보와 맵 정보를 이전 상태인 `prev`를 이용해 생성한다.

   ```java
   int[][] map = new int[4][4]; // 현재 살아있는 물고기만 표시됨
   Fish[] fish new Fish[17]; // 잡아먹힌 물고기 번호의 인덱스는 null
   ```

   * `prev`와 `live`를 통해, **살아있는 물고기만** `map`과 `fish`에 정보를 옮긴다.

2. 물고기를 이동시킨다. -  `void MoveFish(int sx, int sy, int[][] map, Fish[] fish, boolean[] live)`

   : 1번 물고기부터 16번 물고기까지 살아있는 물고기만 이동시킨다. (`live`로 확인)

   * 각 물고기의 방향에 있는 칸을 확인

     * 그 위치가 **상어 자리가 아니고, 범위 내**라면 => 갈 수 있는 칸!

       * 위 조건을 만족하지 않는 칸이라면 방향을 반시계방향으로 45도씩 회전시키며 주변 칸을 확인한다 => 모든 방향을 확인해도 갈 수 있는 칸이 없다면 이 물고기는 이동시키지 않고 패쓰한다.

     * 갈 수 있는 칸을 찾았다면 => 이 칸은 빈칸 or 다른 물고기 칸

       * 물고기 칸이라면, 그 물고기를 현재 물고기의 자리로 옮겨준다. (`fish`와 `map`정보 변경)
       * ***빈칸이라면, 현재 물고기의 자리를 비워준다.***

       그 후 현재 물고기의 위치를 갈 수 있는 그 칸으로 옮겨준다. (빈칸이든, 물고기 칸이든)

       또, 방향을 회전시켰을 수 있으므로 방향도 변경시킨다.

3. 상어가 이동할 수 있는 칸을 찾는다.

   ```java
   ArrayList<Integer> CanGo; // 상어가 갈 수 있는 위치에 있는 물고기 번호
   ```

   * 상어의 방향에 있는 위치를 확인. (상어의 방향에 있는 범위 내의 모든 위치를 확인)

     그 위치에 살아있는 물고기가 있다면 그 번호를 `CanGo`에 추가해준다.

4. `CanGo`가 비었다면 => 상어가 갈 수 있는 칸이 없다는 의미.

   이 때까지 상어가 먹은 물고기 번호의 합인 `sum`과 최종 결과값인 `Max`를 비교해 큰 값으로 `Max`를 갱신하고 `return`.

5. 비어있지않다면, 상어가 잡아먹을 수 있는 물고기 번호 리스트인 `CanGo`를 스캔.

   * 상어는 한번에 한마리만 잡아먹을 수 있으므로 한 마리씩 확인한다.

   현재 물고기 칸으로 상어의 위치를 이동시키고, 그 물고기 번호의 `live`값을 `false`로 변경한다.

   위 상태로 `BackTracking()`메소드 호출.

   호출 뒤 다시 위의 물고기 번호의 `live`값을 `true`로 변경시켜준다. (=> 다음 물고기를 잡아 먹는다면, 현재 물고기는 살아있는 상태이므로)

</br>

## :speaking_head:

 와 확실히 어렵다! 골드 2 인정! 백트래킹할 때 복원시켜줘야하는 게 뭐 뭐 있는지 잘 생각하자

* 처음에 `fish`정보를 이동시켜주고 다시 돌려주지 않았어서 테케 답이 맞지 않았다.

  => 그래서 각 메소드를 호출할 때마다 이전 정보 `prev`로 `map`과 `fish`정보를 생성해주어서 사용하면서 해결

* 근데 테케2번 통과하니까 1번이 다시 안맞아서 디버깅 해보았다

  => 물고기를 이동시킬 때 빈칸으로도 이동시킬 수 있다는 것을 빼먹었고, 이것을 추가

  => 근데, 빈칸으로 이동시킬 때 원래 자리를 비워주지 않아서 틀림

  => 빈칸 이동시 자리 비워주면서 해결하였다





