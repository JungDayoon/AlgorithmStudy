# [BOJ]/[16946] 벽 부수고 이동하기 4

## *- BFS -*

```java
int[][] map; // 주어지는 맵 정보
int[][] gnum; // 빈칸 군집의 번호
int[][] gcnt; // 해당 군집에 속하는 빈칸의 개수
```

1. `map`을 스캔하면서, 빈칸인데 아직 군집 번호가 정해지지 않은 칸이라면,

   `bfs()`수행

   ```java
   void bfs(int x, int y, int chk){}
   ```

   * bfs로 `(x, y)`주변의 빈칸을 확인해, 해당하는 위치의 개수 `cnt`를 계산하고, 각 위치의 `gnum`값을 `chk`로 변경시킨다.

   * 현재 군집에 해당하는 위치는 `ArrayList<int[]> loc`에 추가해준 후, bfs가 끝난 후에 `loc`의 위치들의 `gcnt`값을 `cnt%10`값으로 할당한다.

2. 다시 `map`을 스캔하면서 벽이라면, 그 벽의 상하좌우위치를 확인.

   * 상하좌우 위치의 `gnum`값의 합을 구하는데, 다른 군집일 경우에만 더해준다. (=같은 군집의 `gnum`값은 겹치지 않도록, 한 번만 더할 수 있도록 함. => 군집의 번호를 `Map<Integer, Boolean> done`에 없을 경우에만 더해주고, 그 값을 `done`에 추가)
   * 합을 구했다면, 그 합의 `%10`한 값을 결과 배열인 `ans`에 할당한다.

3. `ans`를 출력 (`StringBuilder` 사용)

</br>

## :speaking_head:

오래 걸렸다 ㅠ

* 처음에는 벽이 있으면 그 때마다 bfs를 하는 방식으로 해결했는데 역시나 *시간초과* 였다.
* 군집에 속하는 개수를 bfs로 구하면서 군집의 번호를 할당해준다음에, dfs로 빈칸의 개수를 `gcnt`에 할당해주는 방식으로 했는데, 또 시간초과가 떴다.
  * 이 방법으로 요것저것 해봤는데 계속 오류가 나서 지혜 방법을 참고했다ㅠ
  * 간단하게 bfs를 실행하면서 지나가는 위치의 좌표를 리스트에 저장해준 후에 다시 그 리스트를 확인하면서 `gcnt`값을 바꿔주면 되는 것이었다 ... .😥
* 그리고 나서도 틀렸었는데 문제에서 주어진 조건인 `%10`하는 것을 잊고 있었었다.

문제 포인트 잘 적어두고, 간단히 구현할 수 있는 방법을 생각해보자 !!!