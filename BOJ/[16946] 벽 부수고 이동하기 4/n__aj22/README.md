# 백준 16946 : 벽 부수고 이동하기 4

## Algorithm

BFS

## Description

`visited` : 방문 여부와, 방문 하고 나서는 묶음의 개수, 묶음 번호를 저장해주는 3차원 배열

1. 기존에는 위치마다 값 1개만 저장하는 일반적인 visited를 사용했는데 아래와 같은 반례를 해결할 방법이 보이지 않아 위치마다 2개의 값 [0 묶음 개수, 묶음 번호]를 저장하는 3차원 배열을 사용했다.
    ```
    3 3
    000
    010
    000
    ```
2. 처음에는 모두 [-1, -1]로 초기화 되어 있다.
3. `visited[y][x][0] == -1`, 즉 방문한 적이 없고, `arr[y][x] == '0'`이라면 bfs를 호출해 이 위치의 0과 같은 공간인 0을 모두 찾아 [0 묶음 개수, 묶음 번호로 바꿔준다.]
    ```
    //예시
    4 5
    11001           [[-1, -1], [-1, -1], [ 2,  0], [ 2,  0], [-1, -1]]
    00111     ->    [[ 3,  1], [ 3,  1], [-1, -1], [-1, -1], [-1, -1]]
    01010           [[ 3,  1], [-1, -1], [ 1,  2], [-1, -1], [ 1,  3]]
    10101           [[-1, -1], [ 1,  4], [-1, -1], [ 1,  5], [-1, -1]]
    ```
4. 1인 위치의 상, 하, 좌, 우의 0의 개수를 모두 더한 후 +1(본인 위치) 한 것이 그 위치에서 이동할 수 있는 칸의 개수 이다. 단 4개의 묶음은 다 다른 묶음이어야 한다.
    ```python
    answer = 1
    check = []
    for k in range(4):
        nexty, nextx = i+dy[k], j+dx[k]
        if(isin(nexty, nextx) and visited[nexty][nextx][0]!=-1 and visited[nexty][nextx][1] not in check):
            answer+=visited[nexty][nextx][0]
            check.append(visited[nexty][nextx][1])
    ```
## Review

