# [BOJ]/[2688] 줄어들지 않아

## *- DP -*

* `long[][] dp = new long[11][maxNum+1]`

  * `dp[i][j]` : `j`자리수가 `i`일 때, 줄어들지 않는 j자리수의 개수
  * 여러 테스트 케이스 중 가장 큰 숫자인 `maxNum`을 저장해두고 그만큼 배열을 생성한다. Bottom-up 방식을 사용하였기때문에 가장 큰 숫자의 경우를 구한다면 나머지 테스트 케이스의 숫자도 답을 구할 수 있다.
  * 숫자의 범위가 `1 <= n <= 64`로 가장 큰 수는 64이다. 줄어들지 않는 64자리수의 개수가 `int`형 범위를 벗어나기 때문에 **`long`타입으로 배열을 생성해야한다**.

  </br>

  * `dp[j][i]`: `i`번째 자리에 `j`가 왔을 때, 줄어들지 않는 `i`자리수의 개수

    * 우선, `dp[0][i]`는 무조건 `1`이다. 

      * `i`번째 자리에 `0`이 있는 줄어들지 않는 `i`자리수의 개수는 한 가지뿐이다. 
      * 예) `dp[0][3]`: 3번째 자리에 0이 왔을 때, 줄어들지 않는 3자리수 => '000' 으로 하나뿐

    * 예를 들어, `dp[3][3]`을 구한다고 할 때,

      3번째 자리에 3이 왔을 때, 줄어들지 않는 3자리 수의 개수이므로,

      1. 2번째 자리에 3이 왔을 때, 줄어들지 않는 2자리 수의 개수

      2. 2번째 자리에 2가 왔을 때, 줄어들지 않는 2자리 수의 개수

      3. 2번째 자리에 1이 왔을 때, 줄어들지 않는 2자리 수의 개수

      4. 2번째 자리에 0이 왔을 때, 줄어들지 않는 2자리 수의 개수

      위 네 가지 개수를 모두 더한 값이 그 답이 된다.

      근데 `dp[2][3]`의 값이 위의 2, 3, 4를 더한 값이 되므로 따라서 점화식을 세워본다면

      `dp[j][i] = dp[j][i-1] + dp[j-1][i]`라고 할 수 있다.

    * 따라서 `i`번째 자리에 `0` ~ `9` 수가 왔을 때의 모든 가지수를 더한 값이 줄어들지 않는 `i`자리수의 개수가 된다.
      * 이 값을 `dp[10][i]`에 저장해주었다.

