# [BOJ]/[12763] 지각하면 안 돼

## *- Dijkstra -*

* `ArrayList<Edge> adj` : 각 edge는 양방향으로 넣어준다

* `int[] dpPrice` : 해당 노드까지 오는데 사용한 돈의 최저값

  * 출발지는 `0`으로, 나머지 노드는 `Integer.MAX_VALUE`로 초기화

* `PriorityQueue`를 사용해 다익스트라를 구현한다

  * `int result` : 마지막 목적지까지 가는데 쓴 돈의 최저 값 (`Integer.MAX_VALUE`로 초기화)

    => (기존의 택시비보다 적은 비용이 들지만 시간이 오래걸리는 경우) 와 (기존의 택시비보다 비용은 많이 들지만 시간이 적게 걸리는 경우) 중 2번째 경우에만 속할 때에는  `dpPrice[]` 값으로 사용한 돈을 계산할 수 없으므로 이 변수를 통해 마지막 노드의 최저 택시비값을 저장한다.

  * 처음에 (노드, 시간, 택시비) = (1, 0, 0)을 먼저 `add()`한 후에 `pq`가 빌 때까지 아래 과정을 반복한다.

    1) `pq`를 poll한다 -> `Edge now`

    2) `now.v`와 인접한 edge를 탐색한다. -> `Edge next`

    * ***최저가격 (`dpPrice[]`)이 갱신될 수 있을 때*** (최저값이 같은 경우도 포함시켜 줌)**,** 주어진 시간 이내에 & 남은 돈으로 택시 탈 수 있다면 `dpPrice[next.v]`값을 `now.price + next.price`로 갱신하고 `pq`에 `add`한다.
      * 그때의 `next.v`가 마지막 목적지 노드라면 `result`에 `dpPrice[]`값을 저장한다.
    * ***최저가격은 갱신할 수 없지만 이 길로 가도 주어진 시간 내에 도착할 때,*** 남은 돈으로 택시 탈 수 있다면 `pq`에 `add`한다.
      * 그 때의 `next.v`가 마지막 목적지 노드라면  `result`에 `now.price + next.price`값을 저장한다. (이때는 최저가격이 아니니까 `dpPrice[]`값은 변경하지 않는다)

  * 위 과정을 끝낸 후에, `result`값이 변하지 않았다면 `-1`을, 변했다면 그 값을 출력시킨다.

</br>

## :speaking_head:

음 ,, 풀긴 했는데 좀 찝찝하다.

처음에 노드의 방문여부를 저장하는 `boolean[] visited`를 사용해서 인접한 edge를 다 확인했다면 `true`로 바꿔주고 그 다음 반복문부터는 그 노드로 가는 edge는 확인할 수 없도록 했는데 *틀렸습니다* 였다. 근데 `visited`를 안쓰니까 *맞았습니다!* 였다!! 반례를 아무리 찾으려고 해봐도 잘 모르겠다 .. 다시 찾아봐야겠다 ㅜ