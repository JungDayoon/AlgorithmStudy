# [BOJ]/[2213] 트리의 독립집합

## *- TreeDP -*

**:heavy_plus_sign: 트리에서의 DP**

* 대부분 DFS를 통해 리프노드까지 향한 다음, 올라오면서 루트의 값 처리.

  :star: 이때, 한 번 방문하면 visited 복구하지 않는다. (방문은 한번만)

* `dp[i]` : `i`를 루트로하는 서브트리의 ~~~

* 경우에 따라, `dp[i][0]`, `dp[i][1]`과 같이 `i`를 포함하는 경우와, 포함하지 않는 경우 두 가지를 고려해주거나, `dp[i][j]`와 같이 `i`와 `j`의 관계에 따른 상태를 저장하기도 한다.

------

#### Main

* `ArrayList<Integer>[] adj` : 인접리스트
* `ArrayList<Integer>[] tree` : `adj`를 이용해 트리형식으로 저장한다.
  * 루트 노드: `1`
* `int[][] dp` 
  * `dp[i][0]` : `i`를 루트로 하는 서브트리에서 **`i`를 포함하지 않을 때**의 최대 독립 집합의 크기
  * `dp[i][1]` : `i`를 루트로 하는 서브트리에서 **`i`를 포함할 때**의 최대 독립 집합의 크기
* `ArrayList<Integer>[][] dpList`
  * `dpList[i][0]` : `i`를 루트로 하는 서브트리에서 **`i`를 포함하지 않을 때**의 최대 독립 집합에 속하는 노드들
  * `dpList[i][1]` : `i`를 루트로 하는 서브트리에서 **`i`를 포함할 때**의 최대 독립 집합에 속하는 노드들

#### Func

* `int dfs(int now, int state)` 

  : `dp[now][state]`값을 계산한 후 리턴. 이미 계산되었다면 그 값을 리턴한다.

  * `dp[i][1]` : `i`를 포함

    => `i`를 포함하면 `i`의 자식노드들은 포함되지 않는다. 

    => `dp[i][1] = SUM(dp[k][0])` (`k`는 `i`의 자식노드) 

  * `dp[i][0]` : `i`를 포함하지 않음

    => `i`를 포함하지 않는다면 `i`의 자식노드는 **포함**해도되고, **포함하지 않**아도 됨

    => 최대 독립 집합의 크기를 구하는 것으로, 위 두 가지 중 큰 값을 `dp[i][0]`에 더해준다.

    => `dp[i][0] = SUM(MAX(dp[k][0], dp[k][1]))` (`k`는 `i`의 자식노드)

  * `dp`값을 구해주는 조건에 맞게 `dpList`도 갱신시킨다.

* `dp[1][0]`, `dp[1][1]` 중 큰 값이 최대 독립 집합의 크기.
  * 둘 중 큰 상태의 `dpList[1][state]`가 그 최대 독립 집합에 속하는 노드들



