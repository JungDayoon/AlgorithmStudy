# [BOJ]/[2624] 동전 바꿔주기

## *- dp -*

```java
int[][] coin_cnt; // 동전 별 개수
int[][] dp; 
```

* `coin_cnt` : `[i][0]`은 `i`번째 동전의 가치, `[i][1]`은 그 동전의 개수

* `dp[i][j]` : `j`원을 동전으로 바꾸려고 할 때, `i`번째 동전과 그보다 작은 동전만을 사용했을 때의 경우의 수

  * 동전을 교환하다보면, 

    예를 들어 20원을 10원과 5원동전으로 교환한다고 하면, `20 = 10*1 + 5*2 = 5*2 + 10*1` 로 바꿀 수 있다. 하지만 두 경우는 같은 경우이므로, 1가지로 계산해야한다.

    => 이러한 경우를 막기 위해 해당 동전보다 작은 동전만을 사용했을 때만을 계산하여 `dp`에 저장한다. (큰 값의 동전을 마지막에 더해주도록 정해준 셈)

---

1. `coin_cnt`를 동전의 가치에 따라 오름차순 정렬한다. 

   * 위의 규칙에 따라 작은 값의 동전부터 확인해주기 위함

2. `1`원부터 `T`원까지의 `dp`값을 계산한다.

   ```java
   void ComputeNumOfCase(int T, int i, int[][] dp)
   ```

   * `T`원을 교환할 때, `i`번째 동전을 마지막에 더해주는 경우의 수를 구하는 메소드.

   * 이 때, 각 동전마다 사용할 수 있는 개수가 정해져있으므로, 

     그 각 개수를 더해주었을 때의 각각의 경우의 수를 구해 합한다.

     * `coin`이 현재 동전의 값이고, `x`를 현재 사용할 개수라고 했을때,

       마지막에 더해줄 값은 `coin*x`원이고, `T`원을 교환하기 위해서 추가로 교환해야할 값은 `T - coin*x`이다.

       * 이 값이 `0`이라면, 현재 동전만 사용해서도 `T`원을 교환할 수 있는 경우로 경우의 수 `+1`

       * `0`보다 작다면, `x`개 이상 사용했을 때에는 `T`원을 교환할 수 없는 경우로 계산을 중단한다. (`break`)

       * `0`보다 큰 값이라면,

         현재의 동전 가치보다 작은 동전만을 사용해서 그 값의 지폐를 교환하는 경우의 수의 합을 구해 경우의 수에 더해준다.

3. 2번 과정을 끝낸 후, `T`원을 교환하는 경우의 수인 `dp[][T]`값의 합을 구해 리턴한다.

</br>

## :speaking_head:

이전에 동전의 개수 제한이 없는 동전 교환하기 문제를 풀었었는데, 그 때 풀었던 방식에 개수를 제한하기 위해 변형하였더니 해결할 수 있었다. 

* 어떤 값을 저장할 지 잘 생각해보자