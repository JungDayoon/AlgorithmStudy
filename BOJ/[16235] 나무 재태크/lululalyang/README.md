# [BOJ]/[16235] 나무 재테크

## *- simulation -* 

* `int[][] A` : 겨울에 뿌리는 양분 값
* `int[][] ground` : 땅의 양분
* `ArrayList<Integer>[][] Treeage` : 각 위치의 나무의 나이 리스트

### solution

* 지난 년 수 `year`이 `K`보다 작을동안 아래 과정을 반복한다.

1. `void Spring(int N, int[][] dieTree)` : 봄

   * `int[][] dieTree` : 죽은 나무의 양분의 1/2를 저장해둔다.

   * 각 위치를 스캔하면서 나무가 있다면,

     그 나무들을 나이에 따라 **오름차순**으로 정렬한다. (나이 어린 나무부터 양분을 먹으므로)

   * 정렬 후, 나무의 나이를 확인

     1. 땅에 나무의 나이만큼 양분이 있다면, 

        땅에서 나이만큼 양분을 없애고, 나무의 나이를 `+1`해준다.

     2. 땅에 그만큼 양분이 없다면,

        그 인덱스의 나무부터 뒤의 나이가 많은 나무는 양분을 못먹고 죽는다.

        * 해당 인덱스를 `die`에 저장해둔 후, `die`부터 그 뒤의 나무는 모두 없앤다.
        * 이때, 제거되는 나무의 나이의 `1/2`를 `dieTree`에 저장해둔다.

2. `void Summer(int N, int[][] dieTree)` : 여름

   * 봄에 저장해둔 죽은 나무의 양분인 `dieTree`를 땅의 양분인 `ground`에 더해준다.

3. `void Autumn(int N)` : 가을
   * 각 위치를 스캔하면서 나무가 있다면,
     * 그 나무의 나이가 `5`의 배수라면, 인접한 위치 8곳에 나이가 `1`인 나무를 추가해준다.
     * 이때, 땅의 범위 내일 때만 추가해준다. = > `Valid(N, r, c)`로 확인
4. `void Winter(int N)` : 겨울
   * 땅의 양분 `ground`에 S2D2가 뿌리는 양분 `A`값을 더해준다.
5. 년 수 `yeat`을 `+1`해준다.

* 위 과정을 마쳤을 때, 남은 나무의 개수가 결과 값이 된다.

  `int CountTree(int N)` : 남은 나무 개수 계산

</br>

## :speaking_head:

처음엔 나무의 정보를 저장하는 리스트를 하나만 두고, *봄* 처리를 해주기 전에 매번 나이순 정렬을 하였는데 이것때문에 *시간초과* 가 난 것 같다.

필요할 때만 정렬을 해줄 수 있도록 해주자 !!