# [BOJ]/[17471] 게리맨더링

## - Simulation -

**전역 변수**

`int Min = Integer.MAX_VALUE` : 최종 결과값. 두 선거구의 인구수 차이 최솟값. 최대값으로 초기화한다.

`int[] P` : 각 구역의 인구수

`ArrayList<Integer>[] adj` : 각 구역의 연결 정보를 인접리스트로 저장한다.

## solution

1. 조합을 이용해 선거구를 2개로 나눈다.

   이 때, 조합에 포함되는 구역과 그렇지 않은 구역 두 가지로 나눈다.

   따라서, `nC1`부터 `nCn/2`까지만 구해준다. (`n/2개보다 큰 조합은 앞의 경우에서 다 포함되므로 처리해 줄 필요없다.)

   `void Comb(int N, int r, int start, ArrayList<Integer> tmp)`

2. 위 과정을 통해 두 선거구를 구했다면, 두 선거구 내의 구역이 다 연결되어있는지 확인한다.

   `boolean ChkOneRange(int N, ArrayList<Integer> Range)`

   * `Range` : 확인하려는 선거구 내에 포함되는 구역들

   * BFS를 이용해 확인한다.

     1. `Range`의 `0`번째 구역을 `q`에 넣고, 인접한 구역들을 확인한다.

     2. 인접 구역이 `Range`에 포함되고, 방문하지 않은 구역이라면 그 구역을 `q`에 넣고 계속 반복한다.

     3. 반복을 끝내고 `Range`에 포함된 구역을 모두 방문했다면, 선거구 내의 모든 구역이 연결되어 있는 것이므로 `true`를 리턴.

        방문하지 않은 구역이 있다면 `false`를 리턴.

3. 만약, 두 선거구 내의 구역이 각각 모두 연결되어있다면,

   각 선거구의 총 인구수를 구해 그 차이값과 `Min`값을 비교하여 작은값으로 `Min`값을 갱신한다.

4. `Min`값이 `Integer.MAX_VALUE`값과 같다면,

   초기화된 값에서 갱신되지 않은 것으로 두 선거구로 나눌 수 없는 경우이다. 따라서 `-1`을 출력.

   그렇지 않으면 `Min`값을 그대로 출력한다.

</br>

## :speaking_head:

> **:timer_clock: *13:05 ~ 13:42 (약 40분)***

조합을 사용하는 문제는 많이 풀어봐서 그런지 금방 풀 수 있었다.