# [BOJ]/[1799] 비숍

## *- BackTracking -*

**전역 변수**

```java
int[][] map; // 비숍 놓을 수 있는지의 여부 정보
boolean[][] visited; // true면 비숍이 놓인 자리, false면 빈자리
int blackMax = 0; // 검은 칸에 놓을 수 있는 비숍 개수 최대값
int whiteMax = 0; // 흰 칸에 놓을 수 있는 비숍 개수 최대값
int[] dx, dy; // 대각선 방향 저장(좌상, 우상, 우하, 좌하)
```

## solution

비숍을 체스판의 검은 칸에 놓는 경우와 흰 칸에 놓는 경우로 나누어 처리한다. (첫 시작 칸이 검은 칸이라고 가정)

=> 한 번에 모두를 확인하여 처리하는 것보다 복잡도가 반으로 줄어든다.

**[ 검은 칸에 놓는 경우 - `void Bishop_black(int x, int y, int cnt)` ]**

`int x, y` : 현재 위치(`x`: 행번호, `y`: 열번호) / `int cnt` : 이 때까지 놓은 비숍의 개수

1. `cnt`가 `blackMax`값보다 크다면 `blackMax`를 갱신한다.

2. 현재 위치를 조정한다.

   1. `y`가 `N`보다 크거나 같다면 다음 행을 확인해야하므로 `x++`, `y`는 만약 짝수 행이라면 `0`으로, 홀수 행이라면 `1`으로 바꿔준다. (검은 칸만 확인하므로)
   2. 변경된 `x`이 `N`보다 크거나 같다면 모든 행을 다 확인한 것으로 종료한다. (`return`)

3. 현재 위치에 비숍을 놓을 수 있는지 확인한다.

   ```java
   boolean ChkValid(int x, int y)
   ```

   1. `map[x][y]`값이 `0`이라면, 비숍을 놓을 수 없는 자리이므로 `false`를 리턴.

   2. 그렇지 않다면, 대각선에 비숍이 있는지 확인한다.

      `dx`, `dy`값을 `x`, `y`에 더해주면서 체스판 범위 내에 있는 대각선 위치 모두를 확인한다. -> 그 위치의 `visited`값이 `true`라면 비숍이 있는 경우로 `false`를 리턴.

   3. 대각선을 모두 확인했을 때 비숍이 없다면 `true`를 리턴.

4. 놓을 수 있다면 `visited`값을 `true`로 바꿔 비숍을 놓았다는 표시를 하고, `(x, y+2, cnt+1)`값으로 메소드를 재귀 호출한다.

   호출한 뒤에 다시 `visited`값을 `false`로 되돌린다.

5. 비숍을 놓지 않았을 경우인 `(x, y+2, cnt)`값으로 메소드를 재귀호출한다.

   * 현재 위치에 비숍을 놓지 않은 경우, 놓은 경우 모두 이 과정을 해주어야 한다.

</br>

* `Bishop_white()`도 수행해준 후, `blackMax + whiteMax`값이 최종 결과값이다.

</br>

## :speaking_head:

처음엔 전체 위치를 한 번에 확인해서 처리했는데 시간 초과가 났다.

다른 사람의 풀이를 참고하였다. 검은 칸, 흰 칸을 나누어 똑같은 방식으로 처리해주었다.