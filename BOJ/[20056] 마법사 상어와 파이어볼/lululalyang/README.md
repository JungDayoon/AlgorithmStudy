# [BOJ]/[20056] 마법사 상어와 파이어볼

## *- Simulation -*

### solution

1. 모든 파이어볼을 이동시킨다.

   * `void MoveBall(int N, ArrayList<Integer>[][] count)`

     * `count[i][j]` : 좌표 (`i`, `j`)에 있는 파이어볼의 index 리스트

     * 각 파이어볼의 속력과 방향에 맞춰 좌표를 바꿔준다.

       ```java
       r += dx[d]*s;
       c += dy[d]*s;
       ```

       그 후, 좌표의 범위에 맞게 조정한다.

       * `int checkValid(int l, int N)`

         1. 현재 위치 `l`이 `N`보다 크면, `l %= N`
         2. 현재 위치 `l`이 `1`보다 작으면, `l = N-(Math.abs(l)%N)`

         *:star2: 이때, **순서를 주의**해야함. (1 -> 2)*

          *만약 현재위치 `l`이 `N`으로 나누어떨어지는 수이면, 1번 과정 후 `0`이 되므로 2번과정을 한번 더 거쳐야 올바른 좌표가 된다.*

     * 이동시킨 후, 그 위치의 좌표에 맞는 `count`에 현재 파이어볼의 index를 추가해준다.

2. `count`리스트를 스캔하면서 한 위치에 2개 이상의 파이어볼이 존재한다면, 문제의 방식에 따라 처리해준다.

   * `void CheckSameLoc(ArrayList<Integer> balls, int r, int c)`
     1. 현재 위치에 있는 파이어볼 `balls`를 스캔하면서 질량과 속도의 총합(`M`, `S`)을 구하고, 방향(`D`)을 구한다.
        * 모든 방향이 홀 또는 짝이라면 `D = 0`
        * 그렇지 않으면 `D = 1`
     2. 만약 `M/5`가 `0`이라면, 나눠지는 각 파이어볼의 질량이 `0`이므로 뒷 과정을 생략한다.
     3. 각 질량이 `0`보다 크다면 4개의 파이어볼을 추가해준다.
        * 질량 `M/5`
        * 속도 `S/더해진 파이어볼의 개수`
        * 방향은 `D=0`이라면 `0, 2, 4, 6` 으로, `D=1`이라면 `1, 3, 5, 7`으로
   * 새로운 파이어볼을 추가해줬다면, 합쳐진 파이어볼은 제거해야하므로 합쳐진 파이어볼의 index를 `remove`리스트에 추가한다.

3. 모든 파이어볼을 이동시키고, 새 파이어볼을 추가해줬다면,

   `remove`를 스캔하면서 삭제해야할 파이어볼을 삭제해준다.

   :star2: Index 주의

4. 명령 횟수 `K`번 만큼 진행했다면, 남아있는 파이어볼의 질량의 총합을 리턴한다.

</br>

## :speaking_head:

* 위의 기울임체로 적어둔 범위를 벗어났을 때의 좌표 처리의 순서 때문에 틀렸었다.
  * 인덱스를 잘 확인하잣
* 처음에 "1행은 N행과 연결되어 있고, 1열은 N열과 연결되어 있다"라는 말을 이해하지 못해서 문제 이해에 시간이 좀 걸렸다 .. 😥

