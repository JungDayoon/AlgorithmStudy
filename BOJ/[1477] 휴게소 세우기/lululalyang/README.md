# [BOJ]/[1477] 휴게소 세우기

## *- Binary Search -*

```java
ArrayList<Integer> rest;
```

* 휴게소의 위치를 저장한다.
* 모두 저장 후, 오름차순으로 정렬.
* 정렬 후, 도착지인 `L`을 추가한다. `N`도 `1` 늘려준다.

1. 이분탐색을 통해 확인할 *"휴게소 없는 구간의 최댓값"* 을 정한다.

   ```java
   int l = 1; // 최소
   int r = 1000; // 최대
   int m = (l + r) / 2; // 확인할 구간 값
   ```

2. `M`개의 휴게소를 세워서 `m`으로 휴게소 없는 구간값이 가능한지 확인한다.

   ```java
   boolean CheckBuild(int N, int M, int dist, ArrayList<Integer> rest)
   ```

   * `dist == m`

   시작 위치 값 `0`부터 시작한다.

   * 현재 위치와 다음 휴게소 사이의 간격이 `dist`이하라면, 

     추가 휴게소 없이 다음 휴게소 갈 수 있는 것으로 그 다음 휴게소를 확인한다.

   * 현재 위치와 다음 휴게소 사이의 간격이 `dist`보다 크다면, 

     추가 휴게소가 필요한 경우.

     * 지을 수 있는 휴게소가 있다면, (`M > 0`)

       `M`값을 `1` 줄이며 휴게소를 1개 세운다. 그리고 현재 위치를 세운 휴게소 위치인 `now + dist`로 바꿔준다.

     * 지을 수 있는 휴게소가 없다면, (`M <= 0`)

       해당 간격 `dist`로 불가능하므로 `false`를 리턴

   * 마지막 도착지까지 갔다면, 해당 간격으로 가능한 것으로 `true`를 리턴

3. 만약 `m`개로 가능하다면, `M`개보다 작거나 같은 휴게소를 지은 것으로 더 지을 수 있다.

   => 최대 간격을 줄인다

   => `r = m-1` , 그 때의 `m`값을 최종값 `ans`에 저장한다.

   `m`개로 불가능하다면, `M`개보다 더 많은 휴게소가 필요한 것

   => 최대 간격을 늘린다

   => `l = m+1`

4. `l <= m`을 만족할 때까지 위의 과정을 반복한다.

   반복을 끝낸 후의 `ans`값을 리턴.

