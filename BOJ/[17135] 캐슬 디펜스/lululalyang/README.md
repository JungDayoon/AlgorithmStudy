# [BOj]/[17135] 캐슬 디펜스

## *- Simulation, BFS -*

**전역 변수**

`int Max = 0` : 최종 결과값. 공격으로 제거할 수 있는 적의 최대 수. `0`으로 초기화

`int[][] state` : 입력받는 적의 위치 정보

`int AllEnemy = 0` : 적의 총 명수. 모든 적이 제거되었는지 확인할 때 사용.

`int[] dx, dy` : 궁수가 공격할 적을 선택할 때의 BFS시 사용할 좌표의 이동값. 

* 궁수는 맨 아래줄에 있으므로 아래로는 가지 않아도 된다.

* 궁수는 가까운 적 중 가장 왼쪽에 있는 적을 공격하므로, 

  `dx, dy`의 인덱스 순서대로 **좌, 상, 우** 로 이동할 수 있도록 저장한다.

## solution

1. 조합을 이용해 궁수를 배치할 위치를 선택한다. => MC3 (열의 개수인 `M`개 중에서 `3`명의 궁수를 놓을 위치)

   `void Comb(int N, int r, int start, ArrayList<Integer> tmp)`

2. `tmp`에 3개의 위치가 추가되었다면, 그 위치에 궁수를 놓고 게임을 시작한다.

   `void GameStart(ArrayList<Integer> Loc)`

   `int turn = 0` : 게임 턴

   `int Arrive = 0` : 성에 도착한 적의 수

   `int Die = 0` : 궁수의 공격으로 죽은 적의 수

   `int[][] Stmp` : 궁수 위치의 경우의 수가 여러가지이므로 원래 적의 위치 정보인 `state`를 복사하여 사용한다.

   * **모든 적이 다 제거될 때까지 아래의 과정 반복 (`AllEnemy == (Arrive+Die)`될 때까지)**

   1. 궁수가 공격한다. 그 때 죽인 적의 수(아래 메소드의 리턴값)를 `Die`에 더해준다.

      `int ArcherAttack(ArrayList<Integer> Loc, int[][] Stmp)`

      : `Loc`에 있는 궁수의 각 위치마다 `BFS`를 이용해 죽일 수 있는 적을 선택한다.

      `ArrayList<int[]> DieEnemy` : 죽인 적의 좌표 리스트

      `q`에는 `r, c, 이동거리`를 저장.

      * 이동 거리가 `D`라면 중단한다.
      * 빈공간이라면, 방문여부체크를 하고 그 위치와 (이동거리+1)을 `q`에 추가한다.
      * 적이라면, 적의 위치를 `int er, ec`에 저장하고 중단한다.

      공격할 수 있는 적이 있다면, 그 위치를 `DieEnemy`에 추가한다.

      * `DieEnemy`를 스캔하면서, 만약 그 위치에 적이 있다면 적을 제거하고 `Die++`을 해준다. 

        => 서로 다른 궁수가 같은 적을 공격할 수 있으므로, 그 위치에 적이 있는지 확인해주어야한다.

   2. 적이 이동한다. 이 때 성에 도착한 적의 수(아래 메소드의 리턴값)를 `Arrive`에 더해준다.

      `int EnemyMove(int[][] Stmp, int turn)`

      1. 맨 마지막 행에 있는 적 => 이동하면 성에 도착하게 되므로 제거한다.

         이러한 적의 수를 구해 리턴한다.

      2. 남아있는 적을 한칸씩 아래로 이동시킨다.

         => 맨 마지막 행부터 `turn`행의 다음 행까지 이전 행의 `Stmp`값을 저장한다.

      3. 가장 위에 있던 적들(`turn`행에 있는 적들)은 아래로 내려갔으므로, 이 위치에 있는 적들은 제거한다.

3. 모든 적이 다 제거되었을 때,

   궁수가 공격한 적의 수 `Die`가 최종값 `Max`보다 크다면 `Max`를 갱신한다.

