# [BOJ]/[11437] LCA

## *- LCA(Lowest Common Ancestor, 최소 공통 조상) -*

#### LCA 알고리즘(Lowest Common Ancestor)

* 최소 공통 조상을 찾는 알고리즘
* **두 노드에서 가장 가까운 공통 조상**을 찾는 알고리즘

:bulb: **HOW**

* 각 노드에서 부모노드를 타고 올라가며 같은 부모를 찾는다.

  **BUT**, 이때 각 노드의 **Level(Depth)가 같아야** 이 방법이 가능하다! 

  => 따라서, ***각 노드의 <u>부모 노드</u>와 <u>레벨</u>***  을 알아야한다.

</br>

1. 트리 저장후, **DFS**를 이용해 각 노드의 부모노드와 레벨을 배열에 저장한다.

   * `ArrayList<Integer>[] g = new ArrayList[N+1]`

     : 트리 정보 

   * `int[] Level` : 각 노드의 레벨

   * `int[] P` : 각 노드의 부모노드

   * `void dfs(int now, int level, int parent)`

     * `int now` : 현재 노드
     * `int level` : 현재 노드의 레벨 (루트 노드의 레벨을 `1`로 둠)

     * `int parent` : 현재 노드의 부모 노드 (루트노드의 부모노드는 `0`으로 설정함)
     * 현재 노드 `now`의 레벨과 부모노드를 저장하고, `now`의 자식노드로 다시 `dfs(자식노드, level+1, now)`를 호출한다.

2. 입력받은 노드 쌍의 가장 가까운 공통 조상을 구한다.

   `int LCA(int u, int v)`

   * 노드 `u`와 `v`의 레벨을 비교해, 더 큰 레벨을 작은 레벨로 맞춰준다.
     * 부모 노드로 타고 가면서
   * 같은 레벨로 맞춰준 후, 만약 두 노드가 같지 않다면 같을 때 까지 각자의 부모노드로 바꿔준다.
   * `u`와 `v`가 같다면 => 그 노드 값이 최초 `u`, `v`의 최소 공통 조상

   예) `LCA(6, 11)`

   ![image](https://user-images.githubusercontent.com/33208360/109816591-42945500-7c74-11eb-89aa-d31f6bb44e89.png)

   * (노드번호, 레벨, 부모노드) 형식

     1. **`u`(6, 3, 2) - `v`(11, 4, 5)** => `v`의 레벨이 더 크므로 (3 < 4) 레벨을 맞춰주기 위해 `v`의 부모 노드로 비교대상을 바꾼다.

     2. **`u`(6, 3, 2) - `v`(5, 3, 2)** => 둘의 레벨이 같으므로 두 노드를 비교. 

        => 두 노드가 다르므로 같을 때 까지 각각의 부모노드로 바꾼다.

     3. **`u`(2, 2, 1) - `v`(2, 2, 1)** => 두 노드가 `2`로 같다

        => 노드`2`가 노드`6`과 노드`11`의 최소 공통 조상이다.