## 분류💁

시뮬레이션


## 접근법

- 3가지 특성 시작점, 시작방향, 세대가 주어진다.

- K(K > 1)세대 드래곤 커브는 K-1세대 드래곤 커브를 끝 점을 기준으로 90도 시계 방향 회전 시킨 다음, 그것을 끝 점에 붙인 것이다.

  -> 이 조건을 규칙을 찾아보면 끝점을 기준으로 방향을 90도 반시계방향 회전시킨 것과 같다.

- 예제 2를 예시로 보면, 드래곤 커브 중 `4 2 1 3` 은

    - 0세대 때 방향 : 1

    - 1세대 때 방향 : 1, 2

    - 2세대 때 방향 : 1, 2, 3, 2

    - 3세대 때 방향 : 1, 2, 3, 2, 3, 0, 3, 2

    - 끝점을 기준으로, 끝점부터 반시계 방향 회전한 것과 똑같다. 2세대에서 3세대로 갈때, 2세대의 끝점 방향인 2의 반시계 방향 값인 3을 push 하게되고, 3의 반시계 방향인 0을 push하고 이렇게 값을 넣어간다.

- 지나가는 곳은 `visited[y][x]=true`로 설정한다. 마지막에 네 좌표가 true인 것만 카운트해서 결과값을 낸다.


## 방향값 정하는 부분
```cpp
  for(int nowg=1;nowg<=g;nowg++){
        for(int i=pow(2,nowg-1)-1;i>=0;i--){ //2^nowg-1
            int rdir=(dirs[i]+1)%4;
            dirs.push_back(rdir);           

            ny=y+dy[rdir];
            nx=x+dx[rdir];

            if(inRange(ny,nx)) {
                map[ny][nx]=true;
            
                y=ny;
                x=nx;
            }  
        }
    }
```



## 후기💡

- 1시간 15분 걸렸다.

- 규칙만 빨리 찾으면 금방 풀 수 있다. 규칙 찾는데 시간을 가장 오래썼다

- 두달전에 풀려다가 손도 못대고 포기한 문제인데, 실력이 그 사이 많이 향상된 것 같다.!
