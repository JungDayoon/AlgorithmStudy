# [Programmers]/[67258] 보석 쇼핑

## *- Map, Set -*

### solution

* `Set<String> kinds = new HashSet<>()` : 보석 종류의 개수를 알기 위한 Set

  > **:star: Java - 배열을 Set으로**
  >
  > ```java
  > kinds.addAll(Arrays.asList(gems));
  > ```

  * `int cnt = kinds.size()` : 위의 Set을 통해서 보석종류의 개수를 구한다.

* `Map<String, Integer> gemmap` : <보석 종류, 확인하고 있는 구간에 포함되는 해당 보석 개수>

* `Queue<String> gemsQ` : 확인하려고 있는 구간에 포함되는 보석 Q (순서대로 들어가있다.)

------

* `int realStart = 0` : 가장 적은 보석을 포함하면서, 시작점이 빠른 구간의 시작점 => 결과값의 시작점이 된다.
  * `0`으로 초기화
* `int start` : 현재 확인하려는 구간의 시작점, `0`으로 초기화
* `int end` : 구간에 포함되는 보석의 개수, 최대값으로 초기화

* `gems`배열을 스캔하면서 아래의 과정을 진행

  1. `gemmap`에 현재 보석이 존재하지 않는다면 `1`개로 추가해주고, 존재하는 보석이라면 그 개수를 늘려준다.

     > **:star: Java - `map.getOrDefault(key값, default값)`**
     >
     > ```java
     > gemmap.put(gems[i], gemmap.getOrDefault(gems[i], 0)+1);
     > ```
     >
     > key값에 해당하는 Entry가 있다면 그에 맞는 value값을 반환하고, 해당하는 Entry가 없다면 설정해놓은 default값을 반환한다.

  2. `gemsQ`에도 현재 보석을 추가한다.

  3. 현재 확인하려는 구간의 첫번째 보석이 연속적으로 시작되지 않도록 처리한다.

     1. `gemsQ`의 가장 첫 보석을 확인

     2. 현재 구간에서 그 보석의 개수가 1개가 아니라면, 

        `gemsQ`에서 제거하고, `start++`을 해준다.

        그리고 하나 제거했으므로 `gemmap`의 개수를 하나 줄여준다.

     3. 첫 보석의 개수가 1개일 때까지 반복

  4. 확인하려는 구간내에 모든 종류의 보석이 포함되고(`gemmap.size() == cnt`), 

     그 구간의 길이가 이전에 구한 길이보다 짧다면(`end > gemsQ.size()`),

     결과값의 시작점인 `realStart`를 `start`로 갱신하고, 포함되는 보석의 개수인 `end`를 `gemsQ`의 개수만큼으로 갱신한다.

* 배열을 모두 스캔한 후의 `realStart`가 문제에서 주어진 조건에 맞는 구간의 시작점.

  realStart는 인덱스값으로 `0`부터 시작하니까 `+1`해준 값이 위치의 번호이다

  * ***따라서, `realStart+1`부터 `realStart+end`까지가 결과값 구간.***

</br>

## :speaking_head:

다른사람의 풀이를 참고해서 풀었다. 이런 생각을 어떻게 하는지 .. .🤦‍♀️🤦‍♂️

* 처음에는 `Map`에 보석의 개수가 아닌 인덱스를 저장해주고, `Map`의 크기가 보석 종류의 개수와 같아지면 그때 `Map`에 있는 가장 작은 인덱스가 시작점, 현재 확인하고 있는 인덱스가 종료점으로 인식해서 결과 리스트에 넣어준 후에, 그 리스트를 구간의 길이와 시작점의 값에 따라서 정렬하였고, 그 첫번째 값을 반환해주었는데 효율성 테스트 몇개를 통과하지 못했다.
* 그래서, 다른 풀이를 참고하여서 `Map`에는 보석의 개수를 저장하고, `Q`를 사용하는 방식으로 해결하였다.