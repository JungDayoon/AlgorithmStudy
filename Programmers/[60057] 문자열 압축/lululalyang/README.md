# [Programmers]/[60057] 문자열 압축

## *- String -*

* `int ans = s.length()` : 리턴값. 압축 문자열의 가장 짧은 길이의 값으로, 기존 문자열의 길이값으로 초기화한다.
* `StringBuilder resultS` : 각 길이의 토큰으로 압축했을 때의 압축 결과 문자열.

#### Solution

* `1`부터 `S.length()`까지의 모든 길이의 토큰으로 잘라보며 가장 짧은 문자열의 길이를 구한다.

1. 먼저, 문자열의 총 길이가 현재 토큰의 길이보다 짧다면 토큰으로 자를 수 없는 것! 

   => 따라서, 문자열 그대로가 압축 결과이다.

   => 이 경우는 패스 ( 결과값을 문자열의 길이로 초기화했기 때문에, 갱신할 필요 없다.)

2. 그렇지 않으면 `idx = 0`부터 토큰의 길이(`tLen`) 만큼 자른 문자열을 `StringBuilder sb`에 저장한다.

   * 다음 토큰의 시작 인덱스를 저장한다. (`int next = idx + tLen`)
   * 압축되는 토큰의 개수를 초기화 한다. (`int cnt = 1`)

   * `idx`가 문자열의 길이보다 작을 동안 아래의 과정을 반복한다.

   1. 만약, 이번 토큰 다음의 토큰을 자를려고 하는데, 남은 문자열이 토큰 길이보다 적게 남아있다면,

      * 근데 `cnt`가 `1`이 아니라면 => 반복되는 토큰이 있었던 것으로 압축시켜야함.

        `resultS`에 `cnt`를 붙여주고, 반복되는 토큰과 그 뒤에 남은 문자열을 붙여준다.

      * `cnt`가 `1`이라면 반복되는 토큰이 없었던 것 => 압축시킬 수 없다.

        `resultS`에 현재 토큰부터 뒤에 남은 문자열까지 모두 붙여준다.

      * 문자열을 마지막 인덱스까지 모두 확인해줬으므로 반복문을 중단한다.

   2. 다음 토큰을 자를 수 있다면, 다음 토큰 시작 인덱스인 `next`부터 토큰의 길이 `tLen`만큼 잘라 `StringBuilder sb_`에 저장해준다.

      * 현재 토큰 `sb`와 다음 토큰 `sb_`가 일치한다면,

        압축되는 토큰이 늘어난 것으로 `cnt++`해주고, `next`를 그 다음 토큰의 인덱스로 갱신시킨 후 다시 위 과정을 반복한다.

      * `sb`와 `sb_`가 다르다면,

        현재 토큰인 `sb`를 `resultS`에 붙여주고, `sb`를 `sb_`로 갱신. 그리고 `idx`를 다음 토큰 시작점인 `next`로 갱신한다.

        => 이 경우 `idx`와 `next`가 같아지므로 다음 반복문 시작 시, `next`를 그 다음 토큰의 인덱스로 갱신해주어야 한다.

3. 하나의 토큰 길이로 위 과정을 끝마치면, 그때의 압축된 문자열인 `resultS`의 길이값과 최종 결과값인 `ans` 중 작은 값으로 `ans`를 갱신한다.

</br>

## :speaking_head:

* 인덱스 처리가 좀 복잡했던 문제.

  코딩하기 전에 정리 어느정도 마치고 시작하기 !

