# [Programmers]/[17677] 뉴스 클러스터링

## *- Map, String -*

#### Solution

1. 우선, 두 문자열 `str1` 과 `str2`를 모두 대문자로 변환시킨다.

   (다중집합 원소 사이를 비교할 때, 대문자와 소문자의 차이는 무시하기 때문)

   > :star: **Java**
   >
   > * `String toUpperCase()` : 대상 문자열을 모두 대문자로 변환
   >
   >   예) `str1.toUpperCase()`
   >
   > * `String toLowerCase()` : 대상 문자열을 모두 소문자로 변환
   >
   >   예) `str2.toLowerCase()`

2. 문자열을 2 글자씩 끊어서 각 문자열 별로 집합을 만든다.

   * 이때, 집합은 `Map<String, Intger>`타입으로 저장한다.
     * `String`: 원소 문자열
     * `Integer` : 현재 집합에서 해당 원소의 개수
   * 끊은 문자열의 두 문자 모두 영문자일 경우에만 `set`에 포함시킨다.
   * `StringBuilder`사용
   * `Map`은 갱신이 안되므로 만약 존재하는 원소가 또 나왔다면 `Map`에서 삭제하고 `Integer`값을 `+1`하여 다시 `put()`해준다.

3. 만들어진 두 집합 `set1`과 `set2` 모두 공집합이라면 `return 1 * 65536`

   (두 집합 모두 공집합이라면 자카드 유사도는 `1`)

4. 교집합의 개수부터 구한다.

   * `set1`의 원소를 스캔하면서 `set2`의 원소를 비교한다.
   * `set2`에 `set1`의 원소와 같은 것이 존재하면 둘 중 `value`값이 작은 값을 (같다면 그 값을) 교집합 개수에 더해준다.
   * 존재하지 않으면 => 교집합에 속하지 않으므로 패스!

5. 그 다음 합집합의 개수를 구한다.

   * 교집합과 같이 `set1`의 원소를 스캔하면서 `set2`의 원소를 비교한다.
   * `set2`에 `set1`과 같은 원소가 존재하면 둘 중 `value`값이 큰 값으로  합집합의 개수에 더해주고, `set2`에서 그 원소를 제거한다. (=> 이후 처리를 위함)
   * `set2`에 `set1`의 원소와 같은 것이 존재하지 않다면 `set1`의 `key`의 `value`값을 합집합의 개수에 더해준다.
   * `set1`의 원소를 모두 스캔한 후에, `set2`에 원소가 남아있다면 그 남은 원소의 `key`의 `value`값을 합집합의 개수에 더해준다.

6. 자카드 유사도는 `0` ~ `1`사이의 값이므로 교집합 개수와 합집합 개수를 `(double)`타입으로 변환시킨 후, 계산해주어 `return`해준다.

## :speaking_head:

* 처음에는 전처리하는 함수를 따로 만들어주었는데, 그 함수안에 대문자 변환처리, 그리고 영문자가 아닌 문자를 제거해주는 처리가 있었다. 하지만, 이 방법은 문제의 의도와 달랐다 !! 
  * 두 글자씩 끊었을 때, 그 문자열에 영문자가 아닌 것이 포함되어있으면 그 문자열은 집합에 포함시키지 않아야 하는 것으로, 영문자 확인은 두 글자씩 끊은 후에 처리해주어야 문제의 의도대로 해결할 수 있다.