# [Programmers]/[67257] 수식 최대화

## *- Simulation, Permutation -*

### solution

1. `expression`을 숫자와 연산자로 나누어 리스트로 만든다. (`ArrayList<String> expList`)

   * 이 때, 사용되는 연산자의 종류를 확인하기 위해 연산자라면 `operator`에 추가해준다.

     * `Map<String, Integer> operator` : <연산자, 연산자 번호>

       연산자마다 `0`번부터의 번호를 붙여준다.

2. 연산자의 개수를 확인해 1개일 때/2개이상일 때의 두 가지 경우로 나누어 처리한다.

   1. **연산자가 1개**라면, `expList`를 스캔하면서

      * 숫자이면 `ArrayList<String> tmpexp`에 추가

      * 연산자라면 `tmpexp`의 마지막 숫자와 `expList`의 다음 숫자를 현재의 연산자로 계산한 후, 그 결과값을 `tmpexp`에 추가한다.

        > :star: **Java : String이 숫자인지 확인**
        >
        > ```java
        > String str = 123123;
        > if(str.matches("[0-9]*")){ // 숫자가 0개이상인 패턴을 찾는 정규식
        >     ...
        > }
        > ```
        >
        > => `.matches(regex)`메소드를 사용한다. (인자는 정규식)

      * 위 과정을 끝낸 후, `tmpexp`에 있는 String이 결과값.
      * `Long`타입으로 바꾸고, 음수라면 양수로 바꿔준다. => 그 값이 결과값 (연산자가 하나이므로, 결과값은 한 가지 뿐)

   2. **연산자가 2개 이상**이라면, 

      연산자의 개수에 맞춰 **순열**을 이용해 우선순위의 경우를 구한다.

      => `ArrayList<ArrayList<Integer>> order`

      * 구한 우선순위의 모든 경우를 이용해 만들수 있는 수를 계산하고, 그 값의 **최대값**을 구한다.

        * 연산자가 1개일 때와 동일하게 계산을 진행한다. 하지만

          만약 연산자라면, 현재의 우선순위에 맞는 연산자일 때만 계산.

          현재 우선순위 연산자와 맞지 않는 연산자라면 숫자와 동일하게 그냥 `tmpList`에 추가한다.

        * 즉, 우선순위의 모든 경우만큼 반복하는데

          * 그 경우 내에서 연산자의 개수만큼 반복하여 계산

## :speaking_head:

처음에 연산자가 1개일 때는 Stack을 이용해서 계산하였는데, 왠지 모르겠지만 22번 테케만 계속 틀렸다ㅜ 그래서 연산자가 2개이상일 때와 동일하게 리스트를 이용하여서 계산했더니 맞았다 !!