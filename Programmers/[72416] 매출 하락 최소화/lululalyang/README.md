# [Programmers]/[72416] 매출 하락 최소화

## *- TreeDP -*

* `ArrayList<Integer>[] adj` : `links`를 이용해 만든 인접리스트.
  * links는 [`a`, `b`] (`a`는 팀장, `b`는 팀원)으로 부모&자식노드가 정해져있으므로 양방향으로 add하지 않아도됨.
  * `adj[a].add(b)`
* `int[][] dp`
  * `dp[i][0]` : `i`가 참석하지 않을 때의 매출액 최솟값
  * `dp[i][1]` : `i`가 참석할 때의 매출액 최솟값

#### solution

* `dp[i][1]` : `i`가 참석할 경우, 자식노드는 참석해도되고, 하지 않아도된다.
  * 매출액의 **최솟값**을 구하고 있으므로 자식노드가 참석할 때와 참석하지 않을 때 중 적은 매출액을 가지는 경우를 더해준다.
  * `dp[i][1] = SUM(MIN(dp[k][0], dp[k][1])) + sales[i-1]` (`k`는 `i`의 자식노드. `sales`는 인덱스`0`부터 이므로 `i-1`로 접근)
* `dp[i][0]` : `i`가 참석하지 않는 경우, 자식 노드 중 하나는 반드시 참석해야 함. 
  * `1`명부터 자식노드의 총 명수 만큼 참석시켰을 때의 최솟값이 `dp[i][0]`
  * **조합**을 사용해 어떤 자식노드를 참석시킬지 결정한다. (`nC1` ~ `nCn`, `n`은 자식노드 개수)
  * `dp[i][0] = MIN(참석시킬 노드들의 dp[k][1] + 참석시키지 않을 노드들의 dp[l][0])` (`k`는 `i`의 자식노드 중 참석하는 노드를 대표. `l`은 `i`의 자식노드 중 참석하지 않는 노드를 대표)

## :speaking_head:

* 처음엔 `i`가 참석하지 않을 때, 자식노드 중 하나만 참석시키는 경우만 생각해주었더니 틀렸다.
  * 조합으로 모든 경우를 고려해야 함!

