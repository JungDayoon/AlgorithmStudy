## 분류💁

트라이

## 접근법

- 모든 길이에 맞는 트라이 배열을 만든다. 최대 길이가 10000이니까 10001개의 배열을 사용한다. `TrieNode* root[10001];`

- ?가 뒤에 있는 경우는 일반적인 트라이노드로 탐색이 가능한데, ?가 앞에 오는 경우에는 불가능하다. 그래서 저장할 때부터 뒤집어진 문자열을 저장하여 뒤에 오는 경우와 똑같이 탐색을 한다.




## 후기💡
- 처음엔 큐를 이용해 ? 길이만큼 탐색해서 살펴보았다. -> 시간 초과

- 각 trie에 cnt[]를 두어 뒤에 오는 길이의 개수를 저장하였다. -> 시간초과. 확실한 이유를 모르겠다

-> 단어의 길이 각각 트라이를 생성해서 풀어야 한다. 

- root와 reversed를 solution 내에 선언하였는데, 효율성 4,5번이 segmeataion fault가 떴다. 지역을 전역으로 바꾸니 해결되었다.. 

- 문제를 해결하는데 어려움을 겪어서, 다른 문제풀이를 참고하여 해결하였다.


