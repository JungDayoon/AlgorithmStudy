# Programmers_67259 [경주로 건설]

## *- Dijkstra, BFS -*

* `int res = Integer.MAX_VALUE` : 경주로 건설 비용 최소값. 최대값으로 초기화
* `Queue<Cost> q` : BFS시 사용할 q
  * `Cost`클래스는 현재 위치좌표 (`x`, `y`), 이때까지 사용된 비용(`cost`), 이전 이동 방향(`prevD`)를 가지고 있다.
* `int[][] board` : 벽위치의 정보 & 해당 위치까지 사용된 최소 비용

1. `q`에 시작점인 `(0, 0)`과 사용한 비용 `0`, 그리고 방향을 `-1`로 `add()`한다.
   * 시작점은 오른쪽과 아래쪽 두 방향으로 갈 수 있기 때문
   * `board[0][0]`은 `1`로 저장해둔다. (탐색에서 제외하기 위해)

2. `q`가 빌 때까지 아래 과정을 반복한다.

   1. 만약, 도착점에 도달했다면 (`x==(N-1) && y==(N-1)`)

      그 때까지 사용한 비용과 `res`를 비교하여 작은 값으로 `res`를 갱신하고, `q`의 다음 원소를 바로 확인한다.

   2. 현재위치 `(x, y)`의 상하좌우를 확인한다.

      * 그 위치가 `board`내부에 존재하고, 벽이 아니라면, 그 위치까지의 비용(`rcost`)을 구한다.

        * 이전 이동방향이 `-1`이라면, 첫 이동이므로 직선 도로밖에 지을 수 없음 => 현재 `cost`에 `100`을 더한 값이 `rcost`

        * 이전 이동방향과 같은 방향으로 이동한다면,

          직선도로이므로 `rcost = cost + 100`

        * 이전 이동방향과 다른 방향으로 이동한다면,

          1. 코너이므로, `rcost = cost + 600` (직선도로 + 코너 = `600`)
          2. 현재 위치로 오기 전 위치로 돌아가는 방향은 다시 돌아가면 안됨 => 이후에 더 적은 비용으로 이동할 때에만 이동시키므로, `600`을 더하게 되면 이전 방향으로 돌아가지 않게 된다.

      * 이동시 필요한 비용을 구한 후,

        1. 처음 방문하는 곳이라면, (`board[rx][ry] == 0`)

           계산한 비용을 `board`에 저장하고, 현재 위치와 비용, 그리고 이동방향을 `q`에 `add()`한다.

        2. 이전에 방문했던 곳이라면,

           계산한 비용이 `board`값보다 작거나 같은 경우에만 `board`값을 갱신하고, `q`에 `add()`한다.

3. `res`가 건설 비용 최솟값이 된다.

</br>

## :speaking_head:

BFS문제는 아무리 풀어도 이렇게 조금 꼬이게되면 아직 너무 어렵다 ㅜㅜ 





