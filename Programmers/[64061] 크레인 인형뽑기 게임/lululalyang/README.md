# [Programmers]/[64061] 크레인 인형뽑기 게임

## *- Simulation -*

### solution

* `int[] loc = new int[N]` : 뽑아야하는 인형의 위치 (맨 위의 인형의 위치)
  * `loc[i]` : `i`번째 위치에서 가장 위의 인형의 위치
  * `loc[i] = N` : 인형이 없는 것을 의미
* `Stack<Integer> basket` : 바구니
* `int res = 0 ` : 사라진 인형의 개수 (결과값)

1. `board`를 스캔하면서 `loc`배열을 완성시킨다.

   * `0`이 아닌 숫자가 있는 위치의 인덱스를 `loc`에 저장

2. `moves`배열값으로 아래 조건을 확인하여 처리한다.

   :star:`loc`이나 `board`배열의 인덱스는 `0`부터 시작하지만, `moves`배열의 원소는 `1`번위치부터 `N`번까지로 이루어져있으므로 `moves[i]-1`을 위치 번호로 간주

   * `int bnum = moves[i] - 1`

   1. `loc[bnum] == N`이라면,

      `bnum`번째 칸에 인형이 없는 경우로, 다음 `bnum`을 확인한다.

   2. 그렇지 않다면, `loc[bnum]`위치에 있는 인형을 꺼내고, `loc[bnum]`값을 `+1`해준다.

   3. 꺼낸 인형의 번호를 바구니에 넣어준다.

      * 이때, 바구니가 비어있다면 아무 처리없이 그냥 `add()`해준다.

      * 바구니에 이미 인형이 있는 상태라면,

        바구니에 가장 위의 인형의 번호와 넣으려는 인형의 번호를 비교한다.

        1. 두 인형이 같다면, 바구니의 가장 윗 인형을 제거하고, `res`값에 `+2`해준다.

           `basket.pop()` : 바구니 맨 윗 인형 제거

        2. 다르다면, 꺼낸 인형을 그냥 바구니에 넣는다(`add()`).

3. 위 과정 후의 `res`값이 사라진 인형의 개수이다.

