# [Programmers]/[64062] 징검다리 건너기

## *- Binary Search -*

### solution

* 이동 가능한 인구수 최소값은 `1`, 최대값은 `200,000,000`이다.

  * `stones`의 각 원소의 범위가 `1`이상 `200,000,000`이기 때문
  * 예) `1` : 모든 원소가 `1`인 경우
  * 예) `200,000,000` : 모든 원소가 `200,000,000`인 경우

  * `k`값에 의해 위 두가지 예시 외의 경우가 생길 수 있다.

* `left`는 `1`로, `right`는 `200,000,000`으로 두고 ***이분탐색*** 을 이용하여 이동가능한 사람 수의 최대값을 구한다.

  * `int mid = (left + right) / 2` : 이동가능한지 확인하려는 인구수

  * `mid`값으로 이동가능한지 확인한다.

    `boolean CheckPoss(int pop, int[] stones, int k)`

    * `int pop` : 확인하려는 이동사람 수

    * `stones[i]` : `i`번째 돌로 갈 수 있는 사람 수

      => 따라서, `(stones[i] - pop)`값이 `0`보다 작거나 같은 돌이 연속으로 `k`개 이상만큼 있으면 `pop`명은 건널 수 없는 것 => `false`를 리턴

    * 위 같은 값이 연속으로 `k`개이상 있지 않을 경우 => `pop`명은 건널 수 있다 => `true`를 리턴

  * 만약 `mid`명이 징검다리를 건널 수 있다면,

     `left = mid + 1`  (더 많은 사람이 건널 수 있는지 확인)

  * 만약 `mid`명이 징검다리를 건널 수 없다면,

    `right = mid - 1` (더 적은 사람이 건널 수 있는지 확인)

  :arrow_right: 위 과정을 `left <= right`를 만족시킬동안만 반복한다.

  * 반복을 종료했을 때의 `left`값이 이동가능한 사람 수의 최대값

</br>

## :speaking_head:

처음에는 건너는 사람 수를 한명씩 늘려가면서 만약 어떤 디딤돌을 밟을 수 없게되면 dfs를 이용해 그 다음으로 밟을 수 있는 돌의 위치를 구해 저장하는 방식으로 풀었는데, 효율성을 하나도 잡지 못했다.

아무리 생각해도 잘 모르겠어서 참고했더니 **이분탐색**이었다.

이분탐색은 문제를 읽었을 때 이분탐색으로 풀어야겠군! 하고 생각하는게 잘 안된다ㅜ 많이 풀어볼 수 있도록 하자 ㅜㅜ