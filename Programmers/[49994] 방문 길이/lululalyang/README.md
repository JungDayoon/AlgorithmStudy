## [Programmers]/[49994] 방문길이

## *- Simulation -*

* `int answer`: 처음 지나간 길의 개수

* `boolean[][] visited = new boolean[21][21]`

  : (-5, -5) ~ (5, 5)의 좌표에 있는 모든 길의 방문여부를 나타내는 배열

  * (짝수, 짝수) 좌표는 좌표평면 내 점에 해당된다
  * (짝, 홀) 또는 (홀, 짝) 좌표는 좌표 내 선에 해당된다
  * (홀, 홀) 좌표는 쓰이지 않음!

* `int x, y`: 현재 위치하고 있는 (x, y)좌표

  * (0, 0)을 `visited`배열에 매칭시켜 `x=10`, `y=10`으로 초기화한다

* `char[] input`: 주어진 문자열 `dirs`을 문자배열로 저장한 것

* `dirs`의 길이만큼 아래과정을 반복한다.

  * 문자가 `U`일 때,

    우선, 이동 후의 좌표가 경계 내에 속하는지 확인 `if(x-2 >= 0)`

    -> 속한다면 `visited[x-1][y]`가 `false`라면 `answer++`해주고 `true`로 바꿔준다 (`(x-1, y)`는 이동할 때 지나가는 길의 좌표)

    -> 현재 좌표를 이동시킨다. (`x -= 2`)

  * 문자가 `L`일 때,

    이동 후 좌표 경계에 속하는지 확인 `if(y-2 >= 0)`

    -> 속한다면 `visited[x][y-1]`가 `false`라면 `answer++`해주고 `true`로

    -> 현재 좌표 이동 (`y -= 2`)

  * 문자가 `R`일 때,

    이동 후 좌표 경계에 속하는지 확인 `if(y+2 < 21)`

    -> 속한다면 `visited[x][y+1]`가 `false`라면 `answer++`해주고 `true`

    -> 현재 좌표 이동 (`y += 2`)

  * 문자가 `D`일 때,

    이동 후 좌표 경계에 속하는지 확인 `if(x+2 < 21)`

    -> 속한다면 `visited[x+1][y]`가 `false`라면 `answer++`해주고 `true`

    -> 현재 좌표 이동 (`x += 2`)ㅇ