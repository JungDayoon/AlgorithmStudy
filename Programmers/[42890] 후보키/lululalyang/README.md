# [Programmers]/[42890] 후보키

## *- Simulation -*

#### Solution

1. 속성으로 만들 수 있는 모든 속성**조합**을 만든다. ( 속성의 idx를 활용 )

   => `static ArrayList<ArrayList<Integer>> idxSet = new ArrayList<>()`

   (전역변수로 둠)

2. 만든 조합을 하나씩 확인한다.

   * 우선, 해당 속성조합이 **유일성**을 만족하는지 확인

     `boolean ChkSame(int N, int M, String[][] relation, int[] attArr)`

     * `int[] attArr` : 현재 속성조합의 인덱스를 가지고 있다.

     * 각 튜플마다 그 인덱스에 해당하는 속성값을 `nowList`에 저장하고, 그 다음 튜플부터 마지막 튜플까지 값을 비교한다.

     * 같은 튜플이 있다면 확인 도중 `false`를 리턴.

     * 모든 튜플을 확인했다면 `true`를 리턴 => 이 속성조합은 유일성을 만족한다는 것

3. 유일성을 만족하는 조합이라면 최소성을 만족하는지 확인한다.

   `boolean AdjustKeySet(ArrayList<Integer> tmp)`

   현재 후보키가 가능한 조합이 저장되어있는 `keySet`에 있는 조합과 `tmp`를 비교한다.

   * `tmp` : 최소성을 만족하는지 확인하려는 조합

   * `tmp`가 `keySet`에 있는 조합을 포함하고 있다면 이는 최소성을 만족하지 않는 것.

     => `false`를 리턴한다.

   * `keySet`의 모든 조합을 확인해도 포함하고 있는 것이 없다면 최소성을 만족하는 것.

     => `true`를 리턴한다.

   * 이때, **포함하는지** 확인은 `contains`가 아닌 `containsAll`을 사용한다.

   > **:star: Java** - `contains()` vs `containsAll()`
   >
   > * `boolean contains(Object o)` 
   >
   >   : 컬렉션이 객체 o를 가지고 있는지 확인한다.
   >
   >   ​	가지고 있으면 `true`를, 그렇지 않으면 `false`를 리턴
   >
   > * `boolean containsAll(Collection c)`
   >
   >   : 컬렉션이 컬렉션 `c`가 포함된 객체를 가지고 있는지 확인한다.
   >
   >   ​	그러한 객체를 가지고 있으면 `true`를, 그렇지 않으면 `false`를 리턴

4. 최소성과 유일성 모두를 만족하는 속성조합만을 `keySet`에 `add()`한다.
5. `keySet`의 크기가 가능한 후보키의 개수.

</br>

## :speaking_head:

* 빙빙 돌고 돌아서 맞춘 문제 .. 

* 처음에 조합을 사용하긴 했는데 모든 조합을 한번에 만들어두지 않고, 

  만약 한 속성으로 유일성이 가능하다면 그 속성만 `keySet`에 추가하고 다음 속성을 확인하였고, 

  한 속성으로 유일성이 가능하지 않으면 그 다음 인덱스의 속성부터 마지막 인덱스의 속성까지를 조합으로 만들어 현재 속성을 추가해서 유일성을 확인하는 .. 뭐 그런 방식으로 풀었다. 

  근데 이렇게 하니까 최소성 확인이 너무 복잡했다. 위 방법을 사용해서 어찌저찌 최소성 확인 메소드를 만들었는데 제출하면 계속 뒷쪽 테케 6-7개가 쭉 틀렸다 ㅜ 반례는 찾지 못했다 ㅜㅜ

* 그래서 그냥 싹다 조합으로 만들어 둔 다음 유일성과 최소성을 확인해주는 방식으로 푸니 해결했다.