## 분류💁

시뮬레이션


## 접근법

- 두 원자가 같은 x 축 상에 속한다 -> 세로로 만날 가능성이 있는지 확인한다.
- 두 원자가 같은 y 축 상에 속한다 -> 가로로 만날 가능성이 있는지 확인한다.
- 두 원자가 `abs(a.y-b.y)== abs(a.x-b.x)`이다 -> 직각으로 만날 가능성이 있는지 확인한다.


</br>
</br>

곧 충돌이 일어날 원자들을 `vector<dists > crush` 에 두 원자 인덱스 값과, 그 거리를 저장한다.

거리를 내림차순 정렬을 하여 가장 먼저 충돌이 일어날 원자들을 충돌시킨다. 동시에 세개, 네개 충돌이 일어나는 경우는 `visited[]`로 확인함



## 시퀀스

1. 원자들이 각각 충돌하는 경우를 가로로 만나는 경우, 세로로 만나는 경우, 직각으로 만나는 경우로 나누어서 각 경우에 해당하면, crush 벡터에 push한다.

2. crush 벡터에 저장되어있는 곧 충돌한 두 원자의 거리를 오름차순으로 정렬 후, 가장 가까운 거리를 충돌시켜 소멸시킨다.

3. crush 벡터가 empty 되는 경우까지 1번을 반복.

</br>

## 후기💡

- 두 원자 사이 거리의 반값을 저장해야하는데, 소수점이 저장되지 않아서 찾는다고 애썼다.. 이유는 잘 모르겠다 그냥 변수를 설정해서 float 로 type casting 하고 값을 넣어주니 잘 작동했다. 휴

- 두 원자가 세로로 만나는 경우, 가로로 만나는 경우, 직각으로 만나는 경우로 로직을 짰는데 예외사항이 너무 많아서 반례들을 참고했다. 예외사항들을 처음부터 잘 짜도록 해보자

- -1000~ 1000 인 범위라서 그냥 시뮬레이션 돌리면 시간초과 뜰 것 같아서 새로운 방법으로 코드를 짜보았다.

</br>
