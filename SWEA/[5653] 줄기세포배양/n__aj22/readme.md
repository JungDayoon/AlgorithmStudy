# SWEA 5653 : 줄기세포배양

## Algorithm

Simulation

## Description
+ arr1 : 시간 정보만 저장하고 있는 이차원 리스트
+ arr2 : [현재 상태로 남은 시간 X, 현재 상태 option] 저장하고 있는 이차원 리스트
  + 현재 상태 : 1 - 비활성상태, 0 - 활성상태, -1 - 죽은상태
  
  -> 처음 줄기세포 크기가 N*M 이더라도 줄기세포는 무한대로 퍼져나갈 수 있기 때문에 두 리스트의 크기는 (2*K+N)*(2*M+N)로 설정해두었다. (한 방향으로만 계속 퍼져나갔을 최악의 경우를 고려함)

1. rindex(num) : 처음 줄기세포 값을 입력받을 때 위치를 num 으로 받아서, 확장해준 리스트의 인덱스 값을 return 해줌

2. spread(time, nN, nM) : 초기 배양시간을 time 으로 가져오고 새로운 N, M 을 파라미터로 가져와서 time 동안의 번식을 진행함

+ new_list : 1시간 흐를 때 마다 퍼지는 줄기세포를 [위치i, 위치j, 시간] 정보를 담아 저장해준다. 같은 곳으로 퍼질 경우를 고려해서 반복문 한번 돌 때 마지막에 처리해줌

+ 세포배양 방식
  
  (참고 : arr2에 세포가 존재하지 않을 경우에는 0이, 존재하는 경우에는 [시간 X, 현재상태] 정보가 담겨있음, 따라서 arr2[i][j][0] = 시간 X, arr2[i][j][1] = 현재상태이다.)
  
  1) arr2[i][j] 가 0 이거나, 0이 아니지만 현재 상태 arr[i][j][1]이 죽은상태(-1)인 경우 : continue
  2) arr2[i][j][1] = 0 즉 비활성화 상태인 경우
    + 아무일도 일어나지 않고 시간만 줄여준다.
    + 단, 시간을 줄여줬는데 0이 된 경우에는 상태를 활성상태로 바꿔주고 시간도 다시 초기 시간으로 바꿔준다.
        ``` python
              elif(arr2[i][j][1]==1):#비활성화 상태
                  arr2[i][j][0]-=1
                  if(arr2[i][j][0]==0):#비활성화 상태 X 가 끝나면
                      arr2[i][j][1] = 0 #활성화 상태로 바꿔주고
                      arr2[i][j][0] = arr1[i][j] #새로 시간 X 설정해준다.    
        ```
  3) arr2[i][j][1] = 1 즉 활성화 상태인 경우
    + 활성화 상태 후 1시간 째면 주위 네 방향을 확인해준 후 번식이 가능한 위치라면 new_list에 담아준다.
    + 이 후 시간을 줄여준다.
    + 단, 시간을 줄여줬는데 0이 된 경우에는 상태를 죽은 상태로 바꿔준다.
        ``` python
              elif(arr2[i][j][1]==0): #활성화 상태인경우
                  if(arr2[i][j][0] == arr1[i][j]):#활성화 상태가 된 후 1시간째이면
                      for k in range(4):#주위 네 방향 확
                          nexti = i+di[k]
                          nextj = j+dj[k]
                          if(arr1[nexti][nextj] == 0):#줄기세포가 퍼질수 있는 빈곳이면
                                new_list.append([nexti, nextj, arr1[i][j]])#new_list에 저장해둠
                  arr2[i][j][0]-=1
                  if(arr2[i][j][0]==0):#활성화상태가 끝나면
                      arr2[i][j][1] = -1 #죽은세포
                      arr2[i][j][0] = arr1[i][j]
        
        ``` 
+ 모든 좌표 확인이 끝나면 new_list 를 돌면서 번식시켜준다.
  + 단 그 위치에 이미 번식된 세포가 존재한다면, 그 세포와 비교해서 더 큰 시간을 가지고 있는 세포 값으로 바꿔준다.
  
        ``` python 
        
              for k in new_list:
              if(arr2[k[0]][k[1]]==0): #아직 빈공간이면
                  arr2[k[0]][k[1]]= [k[2],1] #현재 위치에 새로운 줄기세포를 저장해줌, 비활성화 상태로
                  arr1[k[0]][k[1]] = k[2] #시간정보만 담고 있는 곳에도 시간 저장해줌
              else:#현재 위치에 이미 줄기세포가 퍼졌다면
                  if arr2[k[0]][k[1]][0]<k[2]: #더 긴 시간을 가지고 있는 세포로 변경해줌
                      arr2[k[0]][k[1]][0] = k[2]
                      arr1[k[0]][k[1]] = k[2]
                      
        ``` 
2. main
+ spread(time, N+K+K, M+K+K) 호출
+ 그 후 세포 개수 확인해준다.

## Review

나름 빠른 시간 내에 풀어냈다. 인덱스를 헷갈리지 않게 초기에 잘 설정해주는게 중요한 것 같다.

큰 배열을 시간마다 매번 확인하기 때문에 시간 초과가 날 것 같았는데 다행히도 통과했다.
