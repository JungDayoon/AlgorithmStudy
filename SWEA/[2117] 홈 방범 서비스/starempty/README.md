Simulation (BFS)

1. input 받는 이중 포문

제공하는 모든 `n, m, 2차원배열`을 저장하고 집이 있는 인덱스의 경우 `[i, j]`형태로 따로 `home` 리스트에 넣어준다.

2. 1부터 n+1 while문

while문은 `k`값을 기준으로 회전하며 while문 내 이중포문으로 2차원 배열을 기준으로 한 탐색을 진행한다. 

탐색하면서 내부에 이중포문을 또 둬서 집이 있는지 없는지 확인하는 것이 아니라 `home 리스트`를 만들어뒀기때문에 home길이 만큼만 탐색한다. (다윤, 지혜 도움)

`home 리스트`탐색이 끝나면 최대값 비교를 통하여 k값에 따른 최대 집 개수를 저장한다.

(k값이 총 n+1개인 것은 알고있었지만, 주어진 문제 페이지에서 K=1을 생략하여 2로 시작해서 많이 헤멨다.)

3. 1부터 n+1 for문

인덱싱이 헷갈려서 k값만큼 저장된 최대집개수 리스트 크기만큼 돌도록 설정했다.

이익이 0이상인 것들 중에 집 개수가 가장 큰 것을 고르는 for문이다.

(손해를 보지않는 선에서 최대의 집이라는 말을 쉽게 지나쳐서 시간을 조금 허비했다.)

---

처음에 BFS로 하려고 하다가 그래프가 아닌 이차원배열을 너비우선탐색하는 방법이 와닿지 않아서 거리를 계산하는 방식으로 바꿨다.

`home 리스트`만드는 아이디어가 좋았던 것 같다. 혼자 했으면 절대 생각 못 했을 것 같다. 하지만 이제 이러한 방식으로 시간복잡도를 낮추는 방법도 함께 고안해야겠다.

|i-x|+|j-y|가 여기서 주어진 k값이라는 것이 요긴하게 쓰였다.(검색 도움)

---

드디어 지난주를 마무리했네요... 늦어서 죄송합니다...
